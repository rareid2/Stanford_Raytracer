
\begin{DoxyItemize}
\item \mbox{\hyperlink{Eigen2ToEigen3}{Porting from Eigen2 to Eigen3}}
\item \mbox{\hyperlink{TopicFunctionTakingEigenTypes}{Writing Functions Taking Eigen Types as Parameters}}
\item \mbox{\hyperlink{TopicPreprocessorDirectives}{Preprocessor directives}}
\item \mbox{\hyperlink{TopicAssertions}{Assertions}}
\item \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}}
\item \mbox{\hyperlink{TopicUsingBlasLapack}{Using B\+L\+A\+S/\+L\+A\+P\+A\+CK from Eigen}}
\item \mbox{\hyperlink{TopicUsingIntelMKL}{Using IntelÂ® M\+KL from Eigen}}
\item \mbox{\hyperlink{TopicCUDA}{Using Eigen in C\+U\+DA kernels}}
\item \mbox{\hyperlink{TopicPitfalls}{Common pitfalls}}
\item \mbox{\hyperlink{TopicTemplateKeyword}{The template and typename keywords in C++}}
\item \mbox{\hyperlink{UserManual_UnderstandingEigen}{Understanding Eigen}}
\item \mbox{\hyperlink{TopicCMakeGuide}{Using Eigen in C\+Make Projects}} 
\end{DoxyItemize}\hypertarget{Eigen2ToEigen3}{}\doxysection{Porting from Eigen2 to Eigen3}\label{Eigen2ToEigen3}
This page lists the most important A\+PI changes between Eigen2 and Eigen3, and gives tips to help porting your application from Eigen2 to Eigen3.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_eigen2_to_eigen3_CompatibilitySupport}{}\doxysubsection{Eigen2 compatibility support}\label{_eigen2_to_eigen3_CompatibilitySupport}
Up to version 3.\+2 Eigen provides \href{http://eigen.tuxfamily.org/dox-3.2/Eigen2SupportModes.html}{\texttt{ Eigen2 support modes}}. These are removed now, because they were barely used anymore and became hard to maintain after internal re-\/designs. You can still use them by first \href{http://eigen.tuxfamily.org/dox-3.2/Eigen2ToEigen3.html}{\texttt{ porting your code to Eigen 3.\+2}}.\hypertarget{_eigen2_to_eigen3_Using}{}\doxysubsection{The U\+S\+I\+N\+G\+\_\+\+P\+A\+R\+T\+\_\+\+O\+F\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+\_\+\+E\+I\+G\+E\+N macro}\label{_eigen2_to_eigen3_Using}
The U\+S\+I\+N\+G\+\_\+\+P\+A\+R\+T\+\_\+\+O\+F\+\_\+\+N\+A\+M\+E\+S\+P\+A\+C\+E\+\_\+\+E\+I\+G\+EN macro has been removed. In \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, just do\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{using namespace }\mbox{\hyperlink{namespace_eigen}{Eigen}};}
\end{DoxyCode}
\hypertarget{_eigen2_to_eigen3_ComplexDot}{}\doxysubsection{Dot products over complex numbers}\label{_eigen2_to_eigen3_ComplexDot}
This is the single trickiest change between \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 and \mbox{\hyperlink{namespace_eigen}{Eigen}} 3. It only affects code using {\ttfamily std\+::complex} numbers as scalar type.

\mbox{\hyperlink{namespace_eigen}{Eigen}} 2\textquotesingle{}s dot product was linear in the first variable. \mbox{\hyperlink{namespace_eigen}{Eigen}} 3\textquotesingle{}s dot product is linear in the second variable. In other words, the \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 code
\begin{DoxyCode}{0}
\DoxyCodeLine{x.dot(y) }
\end{DoxyCode}
 is equivalent to the \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 code
\begin{DoxyCode}{0}
\DoxyCodeLine{y.dot(x) }
\end{DoxyCode}
 In yet other words, dot products are complex-\/conjugated in \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 compared to \mbox{\hyperlink{namespace_eigen}{Eigen}} 2. The switch to the new convention was commanded by common usage, especially with the notation $ x^Ty $ for dot products of column-\/vectors.\hypertarget{_eigen2_to_eigen3_VectorBlocks}{}\doxysubsection{Vector blocks}\label{_eigen2_to_eigen3_VectorBlocks}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{vector.start(length)}
\DoxyCodeLine{vector.start<length>()}
\DoxyCodeLine{vector.end(length)}
\DoxyCodeLine{vector.end<length>()}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{vector.head(length)}
\DoxyCodeLine{vector.head<length>()}
\DoxyCodeLine{vector.tail(length)}
\DoxyCodeLine{vector.tail<length>()}
\end{DoxyCode}
 \\\cline{1-2}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_Corners}{}\doxysubsection{Matrix Corners}\label{_eigen2_to_eigen3_Corners}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{matrix.corner(TopLeft,r,c)}
\DoxyCodeLine{matrix.corner(TopRight,r,c)}
\DoxyCodeLine{matrix.corner(BottomLeft,r,c)}
\DoxyCodeLine{matrix.corner(BottomRight,r,c)}
\DoxyCodeLine{matrix.corner<r,c>(TopLeft)}
\DoxyCodeLine{matrix.corner<r,c>(TopRight)}
\DoxyCodeLine{matrix.corner<r,c>(BottomLeft)}
\DoxyCodeLine{matrix.corner<r,c>(BottomRight)}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{matrix.topLeftCorner(r,c)}
\DoxyCodeLine{matrix.topRightCorner(r,c)}
\DoxyCodeLine{matrix.bottomLeftCorner(r,c)}
\DoxyCodeLine{matrix.bottomRightCorner(r,c)}
\DoxyCodeLine{matrix.topLeftCorner<r,c>()}
\DoxyCodeLine{matrix.topRightCorner<r,c>()}
\DoxyCodeLine{matrix.bottomLeftCorner<r,c>()}
\DoxyCodeLine{matrix.bottomRightCorner<r,c>()}
\end{DoxyCode}
  \\\cline{1-2}
\end{longtabu}


Notice that Eigen3 also provides these new convenience methods\+: top\+Rows(), bottom\+Rows(), left\+Cols(), right\+Cols(). See in class \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}.\hypertarget{_eigen2_to_eigen3_CoefficientWiseOperations}{}\doxysubsection{Coefficient wise operations}\label{_eigen2_to_eigen3_CoefficientWiseOperations}
In Eigen2, coefficient wise operations which have no proper mathematical definition (as a coefficient wise product) were achieved using the .cwise() prefix, e.\+g.\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{a.cwise() * b }
\end{DoxyCode}
 In Eigen3 this .cwise() prefix has been superseded by a new kind of matrix type called \mbox{\hyperlink{class_eigen_1_1_array}{Array}} for which all operations are performed coefficient wise. You can easily view a matrix as an array and vice versa using the \mbox{\hyperlink{class_eigen_1_1_matrix_base_a76a9dcb91ec82fbd6e74ca2ac2ae0e07}{Matrix\+Base\+::array()}} and \mbox{\hyperlink{class_eigen_1_1_array_base_ac513167ec762bbf639dc375d314d91d3}{Array\+Base\+::matrix()}} functions respectively. Here is an example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector4f a, b, c;}
\DoxyCodeLine{c = a.array() * b.array();}
\end{DoxyCode}
 Note that the .array() function is not at all a synonym of the deprecated .cwise() prefix. While the .cwise() prefix changed the behavior of the following operator, the array() function performs a permanent conversion to the array world. Therefore, for binary operations such as the coefficient wise product, both sides must be converted to an {\itshape array} as in the above example. On the other hand, when you concatenate multiple coefficient wise operations you only have to do the conversion once, e.\+g.\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector4f a, b, c;}
\DoxyCodeLine{c = a.array().abs().pow(3) * b.array().abs().sin();}
\end{DoxyCode}
 With Eigen2 you would have written\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{c = (a.cwise().abs().cwise().pow(3)).cwise() * (b.cwise().abs().cwise().sin());}
\end{DoxyCode}
\hypertarget{_eigen2_to_eigen3_PartAndExtract}{}\doxysubsection{Triangular and self-\/adjoint matrices}\label{_eigen2_to_eigen3_PartAndExtract}
In \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 you had to play with the part, extract, and marked functions to deal with triangular and selfadjoint matrices. In \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, all these functions have been removed in favor of the concept of {\itshape views\+:} 

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{A.part<UpperTriangular>();}
\DoxyCodeLine{A.part<StrictlyLowerTriangular>(); }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81}{StrictlyLower}}>()}
\end{DoxyCode}
 \\\cline{1-2}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.extract<UpperTriangular>();}
\DoxyCodeLine{A.extract<StrictlyLowerTriangular>();}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81}{StrictlyLower}}>()}
\end{DoxyCode}
 \\\cline{1-2}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.marked<UpperTriangular>();}
\DoxyCodeLine{A.marked<StrictlyLowerTriangular>();}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()}
\DoxyCodeLine{A.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81}{StrictlyLower}}>()}
\end{DoxyCode}
 \\\cline{1-2}
\multicolumn{2}{|l|}{}\\\cline{1-2}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.part<SelfAdfjoint|UpperTriangular>();}
\DoxyCodeLine{A.extract<SelfAdfjoint|LowerTriangular>();}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()}
\DoxyCodeLine{A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>()}
\end{DoxyCode}
 \\\cline{1-2}
\multicolumn{2}{|l|}{}\\\cline{1-2}

\begin{DoxyCode}{0}
\DoxyCodeLine{UpperTriangular}
\DoxyCodeLine{LowerTriangular}
\DoxyCodeLine{UnitUpperTriangular}
\DoxyCodeLine{UnitLowerTriangular}
\DoxyCodeLine{StrictlyUpperTriangular}
\DoxyCodeLine{StrictlyLowerTriangular}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdadd28224d7ea92689930be73c1b50b0ad}{UnitUpper}}}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda8f40b928c10a71ba03e5f75ad2a72fda}{UnitLower}}}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda7b37877e0b9b0df28c9c2b669a633265}{StrictlyUpper}}}
\DoxyCodeLine{\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cda2424988b6fca98be70b595632753ba81}{StrictlyLower}}}
\end{DoxyCode}
  \\\cline{1-2}
\end{longtabu}


\begin{DoxySeeAlso}{See also}
class \mbox{\hyperlink{class_eigen_1_1_triangular_view}{Triangular\+View}}, class \mbox{\hyperlink{class_eigen_1_1_self_adjoint_view}{Self\+Adjoint\+View}}
\end{DoxySeeAlso}
\hypertarget{_eigen2_to_eigen3_TriangularSolveInPlace}{}\doxysubsection{Triangular in-\/place solving}\label{_eigen2_to_eigen3_TriangularSolveInPlace}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{A.triangularSolveInPlace<XxxTriangular>(Y);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{A.triangularView<Xxx>().solveInPlace(Y);}
\end{DoxyCode}
 \\\cline{1-2}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_Decompositions}{}\doxysubsection{Matrix decompositions}\label{_eigen2_to_eigen3_Decompositions}
Some of \mbox{\hyperlink{namespace_eigen}{Eigen}} 2\textquotesingle{}s matrix decompositions have been renamed in \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, while some others have been removed and are replaced by other decompositions in \mbox{\hyperlink{namespace_eigen}{Eigen}} 3.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 }&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }&\cellcolor{\tableheadbgcolor}\textbf{ Notes  }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 }&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }&\cellcolor{\tableheadbgcolor}\textbf{ Notes  }\\\cline{1-3}
\endhead
LU &\mbox{\hyperlink{class_eigen_1_1_full_piv_l_u}{Full\+Piv\+LU}} &See also the new \mbox{\hyperlink{class_eigen_1_1_partial_piv_l_u}{Partial\+Piv\+LU}}, it\textquotesingle{}s much faster  \\\cline{1-3}
QR &\mbox{\hyperlink{class_eigen_1_1_householder_q_r}{Householder\+QR}} &See also the new \mbox{\hyperlink{class_eigen_1_1_col_piv_householder_q_r}{Col\+Piv\+Householder\+QR}}, it\textquotesingle{}s more reliable  \\\cline{1-3}
S\+VD &\mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} &We currently don\textquotesingle{}t have a bidiagonalizing S\+VD; of course this is planned.  \\\cline{1-3}
\mbox{\hyperlink{class_eigen_1_1_eigen_solver}{Eigen\+Solver}} and friends &
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Eigenvalues>} }
\end{DoxyCode}
  &Moved to separate module  \\\cline{1-3}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_LinearSolvers}{}\doxysubsection{Linear solvers}\label{_eigen2_to_eigen3_LinearSolvers}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3}&\cellcolor{\tableheadbgcolor}\textbf{ Notes }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3}&\cellcolor{\tableheadbgcolor}\textbf{ Notes }\\\cline{1-3}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{A.lu();}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{A.fullPivLu();}
\end{DoxyCode}
 &Now A.\+lu() returns a \mbox{\hyperlink{class_eigen_1_1_partial_piv_l_u}{Partial\+Piv\+LU}} \\\cline{1-3}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.lu().solve(B,\&X);}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{X = A.lu().solve(B);}
\DoxyCodeLine{X = A.fullPivLu().solve(B);}
\end{DoxyCode}
 &The returned by value is fully optimized \\\cline{1-3}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.llt().solve(B,\&X);}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{X = A.llt().solve(B);}
\DoxyCodeLine{X = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>.llt().solve(B);}
\DoxyCodeLine{X = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>.llt().solve(B);}
\end{DoxyCode}
 &The returned by value is fully optimized and ~\newline
the selfadjoint\+View A\+PI allows you to select the ~\newline
triangular part to work on (default is lower part) \\\cline{1-3}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.llt().solveInPlace(B);}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{B = A.llt().solve(B);}
\DoxyCodeLine{B = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>.llt().solve(B);}
\DoxyCodeLine{B = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>.llt().solve(B);}
\end{DoxyCode}
 &In place solving \\\cline{1-3}

\begin{DoxyCode}{0}
\DoxyCodeLine{A.ldlt().solve(B,\&X);}
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{X = A.ldlt().solve(B);}
\DoxyCodeLine{X = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>.ldlt().solve(B);}
\DoxyCodeLine{X = A.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>.ldlt().solve(B);}
\end{DoxyCode}
 &The returned by value is fully optimized and ~\newline
the selfadjoint\+View A\+PI allows you to select the ~\newline
triangular part to work on \\\cline{1-3}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_GeometryModule}{}\doxysubsection{Changes in the Geometry module}\label{_eigen2_to_eigen3_GeometryModule}
The Geometry module is the one that changed the most. If you rely heavily on it, it\textquotesingle{}s probably a good idea to use the \href{http://eigen.tuxfamily.org/dox-3.2/Eigen2SupportModes.html}{\texttt{ \char`\"{}\+Eigen 2 support modes\char`\"{}}} to perform your migration.\hypertarget{_eigen2_to_eigen3_Transform}{}\doxysubsection{The Transform class}\label{_eigen2_to_eigen3_Transform}
In \mbox{\hyperlink{namespace_eigen}{Eigen}} 2, the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class didn\textquotesingle{}t really know whether it was a projective or affine transformation. In \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, it takes a new {\itshape Mode} template parameter, which indicates whether it\textquotesingle{}s {\itshape Projective} or {\itshape Affine} transform. There is no default value.

The Transform3f (etc) typedefs are no more. In \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} typedefs explicitly refer to the {\itshape Projective} and {\itshape Affine} modes\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3}&\cellcolor{\tableheadbgcolor}\textbf{ Notes }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3}&\cellcolor{\tableheadbgcolor}\textbf{ Notes }\\\cline{1-3}
\endhead
Transform3f  &Affine3f or Projective3f  &Of course 3f is just an example here   \\\cline{1-3}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_LazyVsNoalias}{}\doxysubsection{Lazy evaluation and noalias}\label{_eigen2_to_eigen3_LazyVsNoalias}
In \mbox{\hyperlink{namespace_eigen}{Eigen}} all operations are performed in a lazy fashion except the matrix products which are always evaluated into a temporary by default. In Eigen2, lazy evaluation could be enforced by tagging a product using the .lazy() function. However, in complex expressions it was not easy to determine where to put the lazy() function. In Eigen3, the lazy() feature has been superseded by the \mbox{\hyperlink{class_eigen_1_1_matrix_base_a2c1085de7645f23f240876388457da0b}{Matrix\+Base\+::noalias()}} function which can be used on the left hand side of an assignment when no aliasing can occur. Here is an example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf a, b, c;}
\DoxyCodeLine{...}
\DoxyCodeLine{c.noalias() += 2 * a.transpose() * b;}
\end{DoxyCode}
 However, the noalias mechanism does not cover all the features of the old .lazy(). Indeed, in some extremely rare cases, it might be useful to explicit request for a lay product, i.\+e., for a product which will be evaluated one coefficient at once, on request, just like any other expressions. To this end you can use the Matrix\+Base\+::lazy\+Product() function, however we strongly discourage you to use it unless you are sure of what you are doing, i.\+e., you have rigourosly measured a speed improvement.\hypertarget{_eigen2_to_eigen3_AlignMacros}{}\doxysubsection{Alignment-\/related macros}\label{_eigen2_to_eigen3_AlignMacros}
The E\+I\+G\+E\+N\+\_\+\+A\+L\+I\+G\+N\+\_\+128 macro has been renamed to E\+I\+G\+E\+N\+\_\+\+A\+L\+I\+G\+N16. Don\textquotesingle{}t be surprised, it\textquotesingle{}s just that we switched to counting in bytes ;-\/)

The \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN }} option still exists in \mbox{\hyperlink{namespace_eigen}{Eigen}} 3, but it has a new cousin\+: \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY.}} It allows to get rid of all static alignment issues while keeping alignment of dynamic-\/size heap-\/allocated arrays. Vectorization of statically allocated arrays is still preserved (unless you define \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE }} =0), at the cost of unaligned memory stores.\hypertarget{_eigen2_to_eigen3_AlignedMap}{}\doxysubsection{Aligned Map objects}\label{_eigen2_to_eigen3_AlignedMap}
A common issue with \mbox{\hyperlink{namespace_eigen}{Eigen}} 2 was that when mapping an array with \mbox{\hyperlink{class_eigen_1_1_map}{Map}}, there was no way to tell \mbox{\hyperlink{namespace_eigen}{Eigen}} that your array was aligned. There was a Force\+Aligned option but it didn\textquotesingle{}t mean that; it was just confusing and has been removed.

New in Eigen3 is the \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8}{Aligned}} option. See the documentation of class \mbox{\hyperlink{class_eigen_1_1_map}{Map}}. Use it like this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Map<Vector4f, Aligned> myMappedVector(some\_aligned\_array);}
\end{DoxyCode}
 There also are related convenience static methods, which actually are the preferred way as they take care of such things as constness\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{result = Vector4f::MapAligned(some\_aligned\_array);}
\end{DoxyCode}
\hypertarget{_eigen2_to_eigen3_StdContainers}{}\doxysubsection{S\+T\+L Containers}\label{_eigen2_to_eigen3_StdContainers}
In Eigen2, {\ttfamily \#include$<$Eigen/\+Std\+Vector$>$} tweaked std\+::vector to automatically align elements. The problem was that that was quite invasive. In Eigen3, we only override standard behavior if you use Eigen\+::aligned\+\_\+allocator$<$\+T$>$ as your allocator type. So for example, if you use std\+::vector$<$\+Matrix4f$>$, you need to do the following change (note that \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\+\_\+allocator}} is under namespace \mbox{\hyperlink{namespace_eigen}{Eigen}})\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 2}&\cellcolor{\tableheadbgcolor}\textbf{ \mbox{\hyperlink{namespace_eigen}{Eigen}} 3 }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<Matrix4f> }
\end{DoxyCode}
  &
\begin{DoxyCode}{0}
\DoxyCodeLine{std::vector<Matrix4f, aligned\_allocator<Matrix4f> > }
\end{DoxyCode}
   \\\cline{1-2}
\end{longtabu}
\hypertarget{_eigen2_to_eigen3_eiPrefix}{}\doxysubsection{Internal ei\+\_\+ prefix}\label{_eigen2_to_eigen3_eiPrefix}
In Eigen2, global internal functions and structures were prefixed by {\ttfamily ei\+\_\+}. In Eigen3, they all have been moved into the more explicit {\ttfamily internal} namespace. So, e.\+g., {\ttfamily ei\+\_\+sqrt(x)} now becomes {\ttfamily internal\+::sqrt(x)}. Of course it is not recommended to rely on \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s internal features. \hypertarget{TopicFunctionTakingEigenTypes}{}\doxysection{Writing Functions Taking Eigen Types as Parameters}\label{TopicFunctionTakingEigenTypes}
Eigen\textquotesingle{}s use of expression templates results in potentially every expression being of a different type. If you pass such an expression to a function taking a parameter of type \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, your expression will implicitly be evaluated into a temporary \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, which will then be passed to the function. This means that you lose the benefit of expression templates. Concretely, this has two drawbacks\+: \begin{DoxyItemize}
\item The evaluation into a temporary may be useless and inefficient; \item This only allows the function to read from the expression, not to write to it.\end{DoxyItemize}
Fortunately, all this myriad of expression types have in common that they all inherit a few common, templated base classes. By letting your function take templated parameters of these base types, you can let them play nicely with Eigen\textquotesingle{}s expression templates.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_function_taking_eigen_types_TopicFirstExamples}{}\doxysubsection{Some First Examples}\label{_topic_function_taking_eigen_types_TopicFirstExamples}
This section will provide simple examples for different types of objects Eigen is offering. Before starting with the actual examples, we need to recapitulate which base objects we can work with (see also \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}).

\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}\+: The common base class for all dense matrix expressions (as opposed to array expressions, as opposed to sparse and special matrix classes). Use it in functions that are meant to work only on dense matrices. \item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}\+: The common base class for all dense array expressions (as opposed to matrix expressions, etc). Use it in functions that are meant to work only on arrays. \item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}}\+: The common base class for all dense matrix expression, that is, the base class for both {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}} and {\ttfamily \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}}. It can be used in functions that are meant to work on both matrices and arrays. \item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}\+: The base class unifying all types of objects that can be evaluated into dense matrices or arrays, for example special matrix classes such as diagonal matrices, permutation matrices, etc. It can be used in functions that are meant to work on any such general type.\end{DoxyItemize}
{\bfseries{ Eigen\+Base Example }}~\newline
~\newline
 Prints the dimensions of the most generic object present in Eigen. It could be any matrix expressions, any dense or sparse matrix and any array. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
{\bfseries{ Dense\+Base Example }}~\newline
~\newline
 Prints a sub-\/block of the dense expression. Accepts any dense matrix or array expression, but no sparse objects and no special matrix classes such as \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{Diagonal\+Matrix}}. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_block(\textcolor{keyword}{const} DenseBase<Derived>\& b, \textcolor{keywordtype}{int} x, \textcolor{keywordtype}{int} y, \textcolor{keywordtype}{int} r, \textcolor{keywordtype}{int} c)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"block: "} << b.block(x,y,r,c) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Array\+Base Example }}~\newline
~\newline
 Prints the maximum coefficient of the array or array-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_max\_coeff(\textcolor{keyword}{const} ArrayBase<Derived> \&a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"max: "} << a.maxCoeff() << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Matrix\+Base Example }}~\newline
~\newline
 Prints the inverse condition number of the given matrix or matrix-\/expression. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} print\_inv\_cond(\textcolor{keyword}{const} MatrixBase<Derived>\& a)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keyword}{typename} JacobiSVD<typename Derived::PlainObject>::SingularValuesType\&}
\DoxyCodeLine{    sing\_vals = a.jacobiSvd().singularValues();}
\DoxyCodeLine{  std::cout << \textcolor{stringliteral}{"inv cond: "} << sing\_vals(sing\_vals.size()-\/1) / sing\_vals(0) << std::endl;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 {\bfseries{ Multiple templated arguments example }}~\newline
~\newline
 Calculate the Euclidean distance between two points. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} DerivedA,\textcolor{keyword}{typename} DerivedB>}
\DoxyCodeLine{\textcolor{keyword}{typename} DerivedA::Scalar squaredist(\textcolor{keyword}{const} MatrixBase<DerivedA>\& p1,\textcolor{keyword}{const} MatrixBase<DerivedB>\& p2)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (p1-\/p2).squaredNorm();}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Notice that we used two template parameters, one per argument. This permits the function to handle inputs of different types, e.\+g., 
\begin{DoxyCode}{0}
\DoxyCodeLine{squaredist(v1,2*v2)}
\end{DoxyCode}
 where the first argument {\ttfamily v1} is a vector and the second argument {\ttfamily 2$\ast$v2} is an expression. ~\newline
~\newline


These examples are just intended to give the reader a first impression of how functions can be written which take a plain and constant \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} or \mbox{\hyperlink{class_eigen_1_1_array}{Array}} argument. They are also intended to give the reader an idea about the most common base classes being the optimal candidates for functions. In the next section we will look in more detail at an example and the different ways it can be implemented, while discussing each implementation\textquotesingle{}s problems and advantages. For the discussion below, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} as well as \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicUsingRefClass}{}\doxysubsection{How to write generic, but non-\/templated function?}\label{_topic_function_taking_eigen_types_TopicUsingRefClass}
In all the previous examples, the functions had to be template functions. This approach allows to write very generic code, but it is often desirable to write non templated function and still keep some level of genericity to avoid stupid copies of the arguments. The typical example is to write functions accepting both a Matrix\+Xf or a block of a Matrix\+Xf. This exactly the purpose of the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class. Here is a simple example\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}
In the first two calls to inv\+\_\+cond, no copy occur because the memory layout of the arguments matches the memory layout accepted by Ref$<$\+Matrix\+Xf$>$. However, in the last call, we have a generic expression that will be automatically evaluated into a temporary Matrix\+Xf by the Ref$<$$>$ object.

A \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} object can also be writable. Here is an example of a function computing the covariance matrix of two input matrices where each row is an observation\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} Ref<const MatrixXf> x, \textcolor{keyword}{const} Ref<const MatrixXf> y, Ref<MatrixXf> C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and here are two examples calling cov without any copy\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf m1, m2, m3}
\DoxyCodeLine{cov(m1, m2, m3);}
\DoxyCodeLine{cov(m1.leftCols<3>(), m2.leftCols<3>(), m3.topLeftCorner<3,3>());}
\end{DoxyCode}
 The Ref$<$$>$ class has two other optional template arguments allowing to control the kind of memory layout that can be accepted without any copy. See the class \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} documentation for the details.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}{}\doxysubsection{In which cases do functions taking plain Matrix or Array arguments work?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsWorking}
Without using template functions, and without the \mbox{\hyperlink{class_eigen_1_1_ref}{Ref}} class, a naive implementation of the previous cov function might look like this 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keywordflow}{return} (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 and contrary to what one might think at first, this implementation is fine unless you require a generic implementation that works with double matrices too and unless you do not care about temporary objects. Why is that the case? Where are temporaries involved? How can code as given below compile? 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x,y,z;}
\DoxyCodeLine{MatrixXf C = cov(x,y+z);}
\end{DoxyCode}
 In this special case, the example is fine and will be working because both parameters are declared as {\itshape const} references. The compiler creates a temporary and evaluates the expression x+z into this temporary. Once the function is processed, the temporary is released and the result is assigned to C.

{\bfseries{Note\+:}} Functions taking {\itshape const} references to \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (or \mbox{\hyperlink{class_eigen_1_1_array}{Array}}) can process expressions at the cost of temporaries.\hypertarget{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}{}\doxysubsection{In which cases do functions taking a plain Matrix or Array argument fail?}\label{_topic_function_taking_eigen_types_TopicPlainFunctionsFailing}
Here, we consider a slightly modified version of the function given above. This time, we do not want to return the result but pass an additional non-\/const paramter which allows us to store the result. A first naive implementation might look as follows. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Note: This code is flawed!}}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixXf\& x, \textcolor{keyword}{const} MatrixXf\& y, MatrixXf\& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{const} \textcolor{keywordtype}{float} num\_observations = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{float}\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorXf y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 When trying to execute the following code 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf C = MatrixXf::Zero(3,6);}
\DoxyCodeLine{cov(x,y, C.block(0,0,3,3));}
\end{DoxyCode}
 the compiler will fail, because it is not possible to convert the expression returned by {\ttfamily Matrix\+Xf\+::block()} into a non-\/const {\ttfamily Matrix\+Xf\&}. This is the case because the compiler wants to protect you from writing your result to a temporary object. In this special case this protection is not intended -- we want to write to a temporary object. So how can we overcome this problem?

The solution which is preferred at the moment is based on a little {\itshape hack}. One needs to pass a const reference to the matrix and internally the constness needs to be cast away. The correct implementation for C98 compliant compilers would be 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C) =}
\DoxyCodeLine{    (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 The implementation above does now not only work with temporary expressions but it also allows to use the function with matrices of arbitrary floating point scalar types.

{\bfseries{Note\+:}} The const cast hack will only work with templated functions. It will not work with the Matrix\+Xf implementation because it is not possible to cast a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression to a \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} reference!\hypertarget{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}{}\doxysubsection{How to resize matrices in generic implementations?}\label{_topic_function_taking_eigen_types_TopicResizingInGenericImplementations}
One might think we are done now, right? This is not completely true because in order for our covariance function to be generically applicable, we want the follwing code to work 
\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXf x = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf y = MatrixXf::Random(100,3);}
\DoxyCodeLine{MatrixXf C;}
\DoxyCodeLine{cov(x, y, C);}
\end{DoxyCode}
 This is not the case anymore, when we are using an implementation taking \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as a parameter. In general, Eigen supports automatic resizing but it is not possible to do so on expressions. Why should resizing of a matrix \mbox{\hyperlink{class_eigen_1_1_block}{Block}} be allowed? It is a reference to a sub-\/matrix and we definitely don\textquotesingle{}t want to resize that. So how can we incorporate resizing if we cannot resize on \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}? The solution is to resize the derived object as in this implementation. 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keywordtype}{void} cov(\textcolor{keyword}{const} MatrixBase<Derived>\& x, \textcolor{keyword}{const} MatrixBase<Derived>\& y, MatrixBase<OtherDerived> \textcolor{keyword}{const} \& C\_)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} Derived::Scalar Scalar;}
\DoxyCodeLine{  \textcolor{keyword}{typedef} \textcolor{keyword}{typename} internal::plain\_row\_type<Derived>::type RowVectorType;}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} Scalar num\_observations = \textcolor{keyword}{static\_cast<}Scalar\textcolor{keyword}{>}(x.rows());}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType x\_mean = x.colwise().sum() / num\_observations;}
\DoxyCodeLine{  \textcolor{keyword}{const} RowVectorType y\_mean = y.colwise().sum() / num\_observations;}
\DoxyCodeLine{}
\DoxyCodeLine{  MatrixBase<OtherDerived>\& C = \textcolor{keyword}{const\_cast<} MatrixBase<OtherDerived>\& \textcolor{keyword}{>}(C\_);}
\DoxyCodeLine{  }
\DoxyCodeLine{  C.derived().resize(x.cols(),x.cols()); \textcolor{comment}{// resize the derived object}}
\DoxyCodeLine{  C = (x.rowwise() -\/ x\_mean).transpose() * (y.rowwise() -\/ y\_mean) / num\_observations;}
\DoxyCodeLine{\}}
\end{DoxyCode}
 This implementation is now working for parameters being expressions and for parameters being matrices and having the wrong size. Resizing the expressions does not do any harm in this case unless they actually require resizing. That means, passing an expression with the wrong dimensions will result in a run-\/time error (in debug mode only) while passing expressions of the correct size will just work fine.

{\bfseries{Note\+:}} In the above discussion the terms \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and \mbox{\hyperlink{class_eigen_1_1_array}{Array}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} can be exchanged and all arguments still hold.\hypertarget{_topic_function_taking_eigen_types_TopicSummary}{}\doxysubsection{Summary}\label{_topic_function_taking_eigen_types_TopicSummary}

\begin{DoxyItemize}
\item To summarize, the implementation of functions taking non-\/writable (const referenced) objects is not a big issue and does not lead to problematic situations in terms of compiling and running your program. However, a naive implementation is likely to introduce unnecessary temporary objects in your code. In order to avoid evaluating parameters into temporaries, pass them as (const) references to \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} (so templatize your function).
\item Functions taking writable (non-\/const) parameters must take const references and cast away constness within the function body.
\item Functions that take as parameters \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} (or \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}}) objects, and potentially need to resize them (in the case where they are resizable), must call resize() on the derived class, as returned by derived(). 
\end{DoxyItemize}\hypertarget{TopicPreprocessorDirectives}{}\doxysection{Preprocessor directives}\label{TopicPreprocessorDirectives}
You can control some aspects of Eigen by defining the preprocessor tokens using {\ttfamily \#define}. These macros should be defined before any Eigen headers are included. Often they are best set in the project options.

This page lists the preprocessor tokens recognized by Eigen.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}{}\doxysubsection{Macros with major effects}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesMajor}
These macros have a major effect and typically break the A\+PI (Application Programming Interface) and/or the A\+BI (Application Binary Interface). This can be rather dangerous\+: if parts of your program are compiled with one option, and other parts (or libraries that you use) are compiled with another option, your program may fail to link or exhibit subtle bugs. Nevertheless, these options can be useful for people who know what they are doing.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+RT}} and {\bfseries{E\+I\+G\+E\+N2\+\_\+\+S\+U\+P\+P\+O\+R\+T\+\_\+\+S\+T\+A\+G\+Enn\+\_\+xxx}} are disabled starting from the 3.\+3 release. Defining one of these will raise a compile-\/error. If you need to compile Eigen2 code, \href{http://eigen.tuxfamily.org/index.php?title=Eigen2}{\texttt{ check this site}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE}} -\/ the type for column and row indices in matrices, vectors and array (Dense\+Base\+::\+Index). Set to {\ttfamily std\+::ptrdiff\+\_\+t} by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+I\+O\+\_\+\+F\+O\+R\+M\+AT}} -\/ the \mbox{\hyperlink{struct_eigen_1_1_i_o_format}{I\+O\+Format}} to use when printing a matrix if no I\+O\+Format is specified. Defaults to the I\+O\+Format constructed by the default constructor \mbox{\hyperlink{struct_eigen_1_1_i_o_format_a840cac6401adc4de421260d63dc3d861}{I\+O\+Format\+::\+I\+O\+Format()}}.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to zero, as are new entries in matrices and arrays after resizing. Not defined by default. \begin{DoxyWarning}{Warning}
The unary (resp. binary) constructor of {\ttfamily 1x1} (resp. {\ttfamily 2x1} or {\ttfamily 1x2}) fixed size matrices is always interpreted as an initialization constructor where the argument(s) are the coefficient values and not the sizes. For instance,
\begin{DoxyCode}{0}
\DoxyCodeLine{Vector2d v(2,1); }
\end{DoxyCode}
 will create a vector with coeficients \mbox{[}2,1\mbox{]}, and {\bfseries{not}} a {\ttfamily 2x1} vector initialized with zeros (i.\+e., \mbox{[}0,0\mbox{]}). If such cases might occur, then it is recommended to use the default constructor with a explicit call to resize\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix<?,SizeAtCompileTime,1> v;}
\DoxyCodeLine{v.resize(size);}
\DoxyCodeLine{Matrix<?,RowsAtCompileTime,ColsAtCompileTime> m;}
\DoxyCodeLine{m.resize(rows,cols);}
\end{DoxyCode}

\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+N\+AN}} -\/ if defined, all entries of newly constructed matrices and arrays are initialized to NaN, as are new entries in matrices and arrays after resizing. This option is especially useful for debugging purpose, though a memory tool like \href{http://valgrind.org/}{\texttt{ valgrind}} is preferable. Not defined by default. \begin{DoxyWarning}{Warning}
See the documentation of {\ttfamily E\+I\+G\+E\+N\+\_\+\+I\+N\+I\+T\+I\+A\+L\+I\+Z\+E\+\_\+\+M\+A\+T\+R\+I\+C\+E\+S\+\_\+\+B\+Y\+\_\+\+Z\+E\+RO} for a discussion on a limitations of these macros when applied to {\ttfamily 1x1}, {\ttfamily 1x2}, and {\ttfamily 2x1} fixed-\/size matrices.
\end{DoxyWarning}

\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+A\+U\+T\+O\+M\+A\+T\+I\+C\+\_\+\+R\+E\+S\+I\+Z\+I\+NG}} -\/ if defined, the matrices (or arrays) on both sides of an assignment {\ttfamily a = b} have to be of the same size; otherwise, Eigen automatically resizes {\ttfamily a} so that it is of the correct size. Not defined by default.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}{}\doxysubsection{C++ standard features}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesCppVersion}
By default, Eigen strive to automatically detect and enable langage features at compile-\/time based on the information provided by the compiler.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER}} -\/ disables usage of C++ features requiring a version greater than E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER. Possible values are\+: 03, 11, 14, 17, etc. If not defined (the default), Eigen enables all features supported by the compiler.
\end{DoxyItemize}

Individual features can be explicitly enabled or disabled by defining the following token to 0 or 1 respectively. For instance, one might limit the C++ version to C++03 by defining E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER=03, but still enable C99 math functions by defining E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH=1.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C99\+\_\+\+M\+A\+TH}} -\/ controls the usage of C99 math functions such as erf, erfc, lgamma, etc. Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+X\+X11\+\_\+\+M\+A\+TH}} -\/ controls the implementation of some functions such as round, logp1, isinf, isnan, etc. Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+R\+V\+A\+L\+U\+E\+\_\+\+R\+E\+F\+E\+R\+E\+N\+C\+ES}} -\/ defines whetehr rvalue references are supported Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+S\+T\+D\+\_\+\+R\+E\+S\+U\+L\+T\+\_\+\+OF}} -\/ defines whether std\+::result\+\_\+of is supported Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+V\+A\+R\+I\+A\+D\+I\+C\+\_\+\+T\+E\+M\+P\+L\+A\+T\+ES}} -\/ defines whether variadic templates are supported Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+O\+N\+S\+T\+E\+X\+PR}} -\/ defines whether relaxed const expression are supported Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$14.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+X\+X11\+\_\+\+C\+O\+N\+T\+A\+I\+N\+E\+RS}} -\/ defines whether S\+TL\textquotesingle{}s containers follows C++11 specifications Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+H\+A\+S\+\_\+\+C\+X\+X11\+\_\+\+N\+O\+E\+X\+C\+E\+PT}} -\/ defines whether noexcept is supported Automatic detection disabled if E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+C\+P\+P\+\_\+\+V\+ER$<$11.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}{}\doxysubsection{Assertions}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesAssertions}
The Eigen library contains many assertions to guard against programming errors, both at compile time and at run time. However, these assertions do cost time and can thus be turned off.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG}} -\/ disables Eigen\textquotesingle{}s assertions if defined. Not defined by default, unless the {\ttfamily N\+D\+E\+B\+UG} macro is defined (this is a standard C++ macro which disables all asserts).
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT}} -\/ if defined, compile-\/time static assertions are replaced by runtime assertions; this saves compilation time. Not defined by default.
\item {\bfseries{eigen\+\_\+assert}} -\/ macro with one argument that is used inside Eigen for assertions. By default, it is basically defined to be {\ttfamily assert}, which aborts the program if the assertion is violated. Redefine this macro if you want to do something else, like throwing an exception.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+P\+L2\+\_\+\+O\+N\+LY}} -\/ disable non M\+P\+L2 compatible features, or in other words disable the features which are still under the L\+G\+PL.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{}\doxysubsection{Alignment, vectorization and performance tweaking}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}

\begin{DoxyItemize}
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+L\+L\+O\+C\+\_\+\+A\+L\+R\+E\+A\+D\+Y\+\_\+\+A\+L\+I\+G\+N\+ED} -\/}} Can be set to 0 or 1 to tell whether default system {\ttfamily malloc} already returns aligned buffers. In not defined, then this information is automatically deduced from the compiler and system preprocessor tokens.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Must be a power of two, or 0. Defines an upper bound on the memory boundary in bytes on which dynamically and statically allocated data may be aligned by Eigen. If not defined, a default value is automatically computed based on architecture, compiler, and OS. This option is typically used to enforce binary compatibility between code/libraries compiled with different S\+I\+MD options. For instance, one may compile A\+VX code and enforce A\+BI compatibility with existing S\+SE code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=16}. In the other way round, since by default A\+VX implies 32 bytes alignment for best performance, one can compile S\+SE code to be A\+BI compatible with A\+VX code by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=32}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} -\/}} Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} but for statically allocated data only. By default, if only {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} is defined, then {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} == {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES}, otherwise a default value is automatically computed based on architecture, compiler, and OS (can be smaller than the default value of E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES on architectures that do not support stack alignment). Let us emphasize that {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+$\ast$\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} define only a diserable upper bound. In practice data is aligned to largest power-\/of-\/two common divisor of {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} and the size of the data, such that memory is not wasted.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE} -\/}} if defined, this disables multi-\/threading. This is only relevant if you enabled Open\+MP. See \mbox{\hyperlink{TopicMultiThreading}{Eigen and multi-\/threading}} for details.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE}} -\/ disables explicit vectorization when defined. Not defined by default, unless alignment is disabled by Eigen\textquotesingle{}s platform test or the user defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN}.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE} -\/}} disables/enables vectorization with unaligned stores. Default is 1 (enabled). If set to 0 (disabled), then expression for which the destination cannot be aligned are not vectorized (e.\+g., unaligned small fixed size vectors or matrices)
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+F\+A\+S\+T\+\_\+\+M\+A\+TH} -\/}} enables some optimizations which might affect the accuracy of the result. This currently enables the S\+SE vectorization of sin() and cos(), and speedups sqrt() for single precision. Defined to 1 by default. Define it to 0 to disable.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+N\+R\+O\+L\+L\+I\+N\+G\+\_\+\+L\+I\+M\+IT} -\/}} defines the size of a loop to enable meta unrolling. Set it to zero to disable unrolling. The size of a loop here is expressed in Eigen\textquotesingle{}s own notion of \char`\"{}number of F\+L\+O\+P\+S\char`\"{}, it does not correspond to the number of iterations or the number of instructions. The default is value 100.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+C\+K\+\_\+\+A\+L\+L\+O\+C\+A\+T\+I\+O\+N\+\_\+\+L\+I\+M\+IT} -\/}} defines the maximum bytes for a buffer to be allocated on the stack. For internal temporary buffers, dynamic memory allocation is employed as a fall back. For fixed-\/size matrices or arrays, exceeding this threshold raises a compile time assertion. Use 0 to set no limit. Default is 128 KB.
\item {\bfseries{{\ttfamily E\+I\+G\+E\+N\+\_\+\+S\+T\+R\+O\+N\+G\+\_\+\+I\+N\+L\+I\+NE} -\/}} This macro is used to qualify critical functions and methods that we expect the compiler to inline. By default it is defined to {\ttfamily \+\_\+\+\_\+forceinline} for M\+S\+VC and I\+CC, and to {\ttfamily inline} for other compilers. A tipical usage is to define it to {\ttfamily inline} for M\+S\+VC users wanting faster compilation times, at the risk of performance degradations in some rare cases for which M\+S\+VC inliner fails to do a good job.
\item {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} -\/ Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment completely. Eigen will not try to align its objects and does not expect that any objects passed to it are aligned. This will turn off vectorization if {\bfseries{E\+I\+G\+E\+N\+\_\+\+U\+N\+A\+L\+I\+G\+N\+E\+D\+\_\+\+V\+E\+C\+T\+O\+R\+I\+ZE=1}}. Not defined by default.
\item {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+G\+N\+\_\+\+S\+T\+A\+T\+I\+C\+A\+L\+LY} -\/ Deprecated, it is a synonym for {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES=0}. It disables alignment of arrays on the stack. Not defined by default, unless {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+A\+L\+I\+GN} is defined.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}{}\doxysubsection{Plugins}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesPlugins}
It is possible to add new methods to many fundamental classes in Eigen by writing a plugin. As explained in the section \mbox{\hyperlink{TopicCustomizing_Plugins}{Extending Matrix\+Base (and other classes)}}, the plugin is specified by defining a {\ttfamily E\+I\+G\+E\+N\+\_\+xxx\+\_\+\+P\+L\+U\+G\+IN} macro. The following macros are supported; none of them are defined by default.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array}{Array}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+A\+R\+R\+A\+Y\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+C\+W\+I\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the Cwise class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+N\+S\+E\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_dynamic_sparse_matrix}{Dynamic\+Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+P\+L\+A\+I\+N\+O\+B\+J\+E\+C\+T\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+M\+A\+P\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_map_base}{Map\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion}{Quaternion}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+Q\+U\+A\+T\+E\+R\+N\+I\+O\+N\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_quaternion_base}{Quaternion\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix}{Sparse\+Matrix}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+M\+A\+T\+R\+I\+X\+B\+A\+S\+E\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+P\+A\+R\+S\+E\+V\+E\+C\+T\+O\+R\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_sparse_vector}{Sparse\+Vector}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+T\+R\+A\+N\+S\+F\+O\+R\+M\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for extending the \mbox{\hyperlink{class_eigen_1_1_transform}{Transform}} class.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+F\+U\+N\+C\+T\+O\+R\+S\+\_\+\+P\+L\+U\+G\+IN}} -\/ filename of plugin for adding new functors and specializations of functor\+\_\+traits.
\end{DoxyItemize}\hypertarget{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}{}\doxysubsection{Macros for Eigen developers}\label{_topic_preprocessor_directives_TopicPreprocessorDirectivesDevelopers}
These macros are mainly meant for people developing Eigen and for testing purposes. Even though, they might be useful for power users and the curious for debugging and testing purpose, they {\bfseries{should}} {\bfseries{not}} {\bfseries{be}} {\bfseries{used}} by real-\/word code.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+T\+O\+\_\+\+R\+O\+W\+\_\+\+M\+A\+J\+OR}} -\/ when defined, the default storage order for matrices becomes row-\/major instead of column-\/major. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+D\+E\+B\+U\+G\+G\+I\+NG}} -\/ if defined, enables assertions in Eigen\textquotesingle{}s internal routines. This is useful for debugging Eigen itself. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, any request from inside the Eigen to allocate memory from the heap results in an assertion failure. This is useful to check that some routine does not allocate memory dynamically. Not defined by default.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+R\+U\+N\+T\+I\+M\+E\+\_\+\+N\+O\+\_\+\+M\+A\+L\+L\+OC}} -\/ if defined, a new switch is introduced which can be turned on and off by calling {\ttfamily set\+\_\+is\+\_\+malloc\+\_\+allowed(bool)}. If malloc is not allowed and Eigen tries to allocate memory dynamically anyway, an assertion failure results. Not defined by default. 
\end{DoxyItemize}\hypertarget{TopicAssertions}{}\doxysection{Assertions}\label{TopicAssertions}
\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_assertions_PlainAssert}{}\doxysubsection{Assertions}\label{_topic_assertions_PlainAssert}
The macro eigen\+\_\+assert is defined to be {\ttfamily eigen\+\_\+plain\+\_\+assert} by default. We use eigen\+\_\+plain\+\_\+assert instead of {\ttfamily assert} to work around a known bug for G\+CC $<$= 4.\+3. Basically, eigen\+\_\+plain\+\_\+assert {\itshape is} {\ttfamily assert}.\hypertarget{_topic_assertions_RedefineAssert}{}\doxysubsubsection{Redefining assertions}\label{_topic_assertions_RedefineAssert}
Both eigen\+\_\+assert and eigen\+\_\+plain\+\_\+assert are defined in \mbox{\hyperlink{_macros_8h_source}{Macros.\+h}}. Defining eigen\+\_\+assert indirectly gives you a chance to change its behavior. You can redefine this macro if you want to do something else such as throwing an exception, and fall back to its default behavior with eigen\+\_\+plain\+\_\+assert. The code below tells \mbox{\hyperlink{namespace_eigen}{Eigen}} to throw an std\+::runtime\+\_\+error\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <stdexcept>}}
\DoxyCodeLine{\textcolor{preprocessor}{\#undef eigen\_assert}}
\DoxyCodeLine{\textcolor{preprocessor}{\#define eigen\_assert(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  if (!(x)) \{ throw (std::runtime\_error("Put your message here")); \}}}
\end{DoxyCode}
\hypertarget{_topic_assertions_DisableAssert}{}\doxysubsubsection{Disabling assertions}\label{_topic_assertions_DisableAssert}
Assertions cost run time and can be turned off. You can suppress eigen\+\_\+assert by defining {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} {\bfseries{before}} including \mbox{\hyperlink{namespace_eigen}{Eigen}} headers. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+D\+E\+B\+UG} is undefined by default unless {\ttfamily N\+D\+E\+B\+UG} is defined.\hypertarget{_topic_assertions_StaticAssert}{}\doxysubsection{Static assertions}\label{_topic_assertions_StaticAssert}
Static assertions are not standardized until C++11. However, in the \mbox{\hyperlink{namespace_eigen}{Eigen}} library, there are many conditions can and should be detectedat compile time. For instance, we use static assertions to prevent the code below from compiling.


\begin{DoxyCode}{0}
\DoxyCodeLine{Matrix3d()  + Matrix4d();   \textcolor{comment}{// adding matrices of different sizes}}
\DoxyCodeLine{Matrix4cd() * Vector3cd();  \textcolor{comment}{// invalid product known at compile time}}
\end{DoxyCode}


Static assertions are defined in \mbox{\hyperlink{_static_assert_8h_source}{Static\+Assert.\+h}}. If there is native static\+\_\+assert, we use it. Otherwise, we have implemented an assertion macro that can show a limited range of messages.

One can easily come up with static assertions without messages, such as\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define STATIC\_ASSERT(x) \(\backslash\)}}
\DoxyCodeLine{\textcolor{preprocessor}{  switch(0) \{ case 0: case x:; \}}}
\end{DoxyCode}


However, the example above obviously cannot tell why the assertion failed. Therefore, we define a {\ttfamily struct} in namespace Eigen\+::internal to handle available messages.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{bool} condition>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion \{\};}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keyword}{template}<>}
\DoxyCodeLine{\textcolor{keyword}{struct }static\_assertion<true>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{enum} \{}
\DoxyCodeLine{    YOU\_TRIED\_CALLING\_A\_VECTOR\_METHOD\_ON\_A\_MATRIX,}
\DoxyCodeLine{    YOU\_MIXED\_VECTORS\_OF\_DIFFERENT\_SIZES,}
\DoxyCodeLine{    \textcolor{comment}{// see StaticAssert.h for all enums.}}
\DoxyCodeLine{  \};}
\DoxyCodeLine{\};}
\end{DoxyCode}


And then, we define E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T(\+C\+O\+N\+D\+I\+T\+I\+O\+N,\+M\+S\+G) to access Eigen\+::internal\+::static\+\_\+assertion$<$bool(\+C\+O\+N\+D\+I\+T\+I\+O\+N)$>$\+::\+M\+SG. If the condition evaluates into {\ttfamily false}, your compiler displays a lot of messages explaining there is no M\+SG in static\+\_\+assert$<$false$>$. Nevertheless, this is {\itshape not} in what we are interested. As you can see, all members of static\+\_\+assert$<$true$>$ are A\+L\+L\+\_\+\+C\+A\+P\+S\+\_\+\+A\+N\+D\+\_\+\+T\+H\+E\+Y\+\_\+\+A\+R\+E\+\_\+\+S\+H\+O\+U\+T\+I\+NG.

\begin{DoxyWarning}{Warning}
When using this macro, M\+SG should be a member of static\+\_\+assertion$<$true$>$, or the static assertion {\bfseries{always}} fails. Currently, it can only be used in function scope.
\end{DoxyWarning}
\hypertarget{_topic_assertions_DerivedStaticAssert}{}\doxysubsubsection{Derived static assertions}\label{_topic_assertions_DerivedStaticAssert}
There are other macros derived from E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT to enhance readability. Their names are self-\/explanatory.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+F\+I\+X\+E\+D\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is fixed size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+D\+Y\+N\+A\+M\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} is dynamic size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+L\+V\+A\+L\+U\+E(\+Derived)}} -\/ failes if {\itshape Derived} is read-\/only.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+A\+R\+R\+A\+Y\+X\+P\+R(\+Derived)}} -\/ passes if {\itshape Derived} is an array expression.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+X\+P\+R\+\_\+\+K\+I\+N\+D(\+Derived1, Derived2)}} -\/ failes if the two expressions are an array one and a matrix one.
\end{DoxyItemize}

Because \mbox{\hyperlink{namespace_eigen}{Eigen}} handles both fixed-\/size and dynamic-\/size expressions, some conditions cannot be clearly determined at compile time. We classify them into strict assertions and permissive assertions.\hypertarget{_topic_assertions_StrictAssertions}{}\doxyparagraph{Strict assertions}\label{_topic_assertions_StrictAssertions}
These assertions fail if the condition {\bfseries{may not}} be met. For example, Matrix\+Xd may not be a vector, so it fails E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+LY.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+O\+N\+L\+Y(\+T\+Y\+P\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector type.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, S\+I\+Z\+E)}} -\/ passes if {\itshape T\+Y\+PE} must be a vector of the given size.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+P\+E\+C\+I\+F\+I\+C\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E, R\+O\+W\+S, C\+O\+L\+S)}} -\/ passes if {\itshape T\+Y\+PE} must be a matrix with given rows and columns.
\end{DoxyItemize}\hypertarget{_topic_assertions_PermissiveAssertions}{}\doxyparagraph{Permissive assertions}\label{_topic_assertions_PermissiveAssertions}
These assertions fail if the condition {\bfseries{cannot}} be met. For example, Matrix\+Xd and Matrix4d may have the same size, so they pass E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+ZE.


\begin{DoxyItemize}
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two vector expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+A\+M\+E\+\_\+\+M\+A\+T\+R\+I\+X\+\_\+\+S\+I\+Z\+E(\+T\+Y\+P\+E0,\+T\+Y\+P\+E1)}} -\/ fails if the two matrix expression types must have different sizes.
\item {\bfseries{E\+I\+G\+E\+N\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+R\+T\+\_\+\+S\+I\+Z\+E\+\_\+1x1(\+T\+Y\+P\+E)}} -\/ fails if {\itshape T\+Y\+PE} cannot be an 1x1 expression.
\end{DoxyItemize}

See \mbox{\hyperlink{_static_assert_8h_source}{Static\+Assert.\+h}} for details such as what messages they throw.\hypertarget{_topic_assertions_DisableStaticAssert}{}\doxysubsubsection{Disabling static assertions}\label{_topic_assertions_DisableStaticAssert}
If {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is defined, static assertions turn into {\ttfamily eigen\+\_\+assert}\textquotesingle{}s, working like\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#define EIGEN\_STATIC\_ASSERT(CONDITION,MSG) eigen\_assert((CONDITION) \&\& \#MSG);}}
\end{DoxyCode}


This saves compile time but consumes more run time. {\ttfamily E\+I\+G\+E\+N\+\_\+\+N\+O\+\_\+\+S\+T\+A\+T\+I\+C\+\_\+\+A\+S\+S\+E\+RT} is undefined by default. \hypertarget{TopicMultiThreading}{}\doxysection{Eigen and multi-\/threading}\label{TopicMultiThreading}
\hypertarget{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}{}\doxysubsection{Make Eigen run in parallel}\label{_topic_multi_threading_TopicMultiThreading_MakingEigenMT}
Some \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s algorithms can exploit the multiple cores present in your hardware. To this end, it is enough to enable Open\+MP on your compiler, for instance\+: G\+CC\+: {\ttfamily -\/fopenmp} I\+CC\+: {\ttfamily -\/openmp} M\+S\+VC\+: check the respective option in the build properties. You can control the number of thread that will be used using either the Open\+MP A\+PI or \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s A\+PI using the following priority\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{OMP\_NUM\_THREADS=n ./my\_program}
\DoxyCodeLine{omp\_set\_num\_threads(n);}
\DoxyCodeLine{\mbox{\hyperlink{namespace_eigen_af9cd17c2fe18204239cd11c88c120b50}{Eigen::setNbThreads}}(n);}
\end{DoxyCode}
 Unless set\+Nb\+Threads has been called, \mbox{\hyperlink{namespace_eigen}{Eigen}} uses the number of threads specified by Open\+MP. You can restore this behavior by calling
\begin{DoxyCode}{0}
\DoxyCodeLine{\mbox{\hyperlink{namespace_eigen_af9cd17c2fe18204239cd11c88c120b50}{setNbThreads}}(0); }
\end{DoxyCode}
 You can query the number of threads that will be used with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{n = \mbox{\hyperlink{namespace_eigen_a9aca97d83e21b91a04ec079360dfffeb}{Eigen::nbThreads}}( );}
\end{DoxyCode}
 You can disable \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s multi threading at compile time by defining the E\+I\+G\+E\+N\+\_\+\+D\+O\+N\+T\+\_\+\+P\+A\+R\+A\+L\+L\+E\+L\+I\+ZE preprocessor token.

Currently, the following algorithms can make use of multi-\/threading\+:
\begin{DoxyItemize}
\item general dense matrix -\/ matrix products
\item \mbox{\hyperlink{class_eigen_1_1_partial_piv_l_u}{Partial\+Piv\+LU}}
\item row-\/major-\/sparse $\ast$ dense vector/matrix products
\item \mbox{\hyperlink{class_eigen_1_1_conjugate_gradient}{Conjugate\+Gradient}} with {\ttfamily Lower$\vert$\+Upper} as the {\ttfamily Up\+Lo} template parameter.
\item \mbox{\hyperlink{class_eigen_1_1_bi_c_g_s_t_a_b}{Bi\+C\+G\+S\+T\+AB}} with a row-\/major sparse matrix format.
\item \mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Least\+Squares\+Conjugate\+Gradient}}
\end{DoxyItemize}\hypertarget{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}{}\doxysubsection{Using Eigen in a multi-\/threaded application}\label{_topic_multi_threading_TopicMultiThreading_UsingEigenWithMT}
In the case your own application is multithreaded, and multiple threads make calls to \mbox{\hyperlink{namespace_eigen}{Eigen}}, then you have to initialize \mbox{\hyperlink{namespace_eigen}{Eigen}} by calling the following routine {\bfseries{before}} creating the threads\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include <Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main(\textcolor{keywordtype}{int} argc, \textcolor{keywordtype}{char}** argv)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen::initParallel}}();}
\DoxyCodeLine{  }
\DoxyCodeLine{  ...}
\DoxyCodeLine{\}}
\end{DoxyCode}


\begin{DoxyNote}{Note}
With \mbox{\hyperlink{namespace_eigen}{Eigen}} 3.\+3, and a fully C++11 compliant compiler (i.\+e., \href{http://en.cppreference.com/w/cpp/language/storage_duration\#Static_local_variables}{\texttt{ thread-\/safe static local variable initialization}}), then calling {\ttfamily \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{init\+Parallel()}}} is optional.
\end{DoxyNote}
\begin{DoxyWarning}{Warning}
note that all functions generating random matrices are {\bfseries{not}} re-\/entrant nor thread-\/safe. Those include \mbox{\hyperlink{class_eigen_1_1_dense_base_ae814abb451b48ed872819192dc188c19}{Dense\+Base\+::\+Random()}}, and \mbox{\hyperlink{class_eigen_1_1_dense_base_ac476e5852129ba32beaa1a8a3d7ee0db}{Dense\+Base\+::set\+Random()}} despite a call to \mbox{\hyperlink{namespace_eigen_a820c0e0460934cc17eb6dacbad54a9f5}{Eigen\+::init\+Parallel()}}. This is because these functions are based on std\+::rand which is not re-\/entrant. For thread-\/safe random generator, we recommend the use of boost\+::random or c++11 random feature.
\end{DoxyWarning}
In the case your application is parallelized with Open\+MP, you might want to disable \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s own parallization as detailed in the previous section. \hypertarget{TopicUsingBlasLapack}{}\doxysection{Using B\+L\+A\+S/\+L\+A\+P\+A\+CK from Eigen}\label{TopicUsingBlasLapack}
Since Eigen version 3.\+3 and later, any F77 compatible B\+L\+AS or L\+A\+P\+A\+CK libraries can be used as backends for dense matrix products and dense matrix decompositions. For instance, one can use \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ IntelÂ® M\+KL}}, Apple\textquotesingle{}s Accelerate framework on O\+SX, \href{http://www.openblas.net/}{\texttt{ Open\+B\+L\+AS}}, \href{http://www.netlib.org/lapack}{\texttt{ Netlib L\+A\+P\+A\+CK}}, etc.

Do not miss this \mbox{\hyperlink{_topic_using_intel_m_k_l}{page }} for further discussions on the specific use of IntelÂ® M\+KL (also includes V\+ML, P\+A\+R\+D\+I\+SO, etc.)

In order to use an external B\+L\+AS and/or L\+A\+P\+A\+CK library, you must link you own application to the respective libraries and their dependencies. For L\+A\+P\+A\+CK, you must also link to the standard \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} library, which is used as a convenient think layer between Eigen\textquotesingle{}s C++ code and L\+A\+P\+A\+CK F77 interface. Then you must activate their usage by defining one or multiple of the following macros ({\bfseries{before}} including any Eigen\textquotesingle{}s header)\+:

\begin{DoxyNote}{Note}
For Mac users, in order to use the lapack version shipped with the Accelerate framework, you also need the lapacke library. Using \href{https://www.macports.org/}{\texttt{ Mac\+Ports}}, this is as easy as\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{sudo port install lapack}
\end{DoxyCode}
 and then use the following link flags\+: {\ttfamily -\/framework} {\ttfamily Accelerate} {\ttfamily /opt/local/lib/lapack/liblapacke}.dylib
\end{DoxyNote}
\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines (compatible with any F77 B\+L\+AS interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack (compatible with any F77 L\+A\+P\+A\+CK interface) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithms of lower numerical robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
\end{longtabu}


When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to B\+L\+AS or L\+A\+P\+A\+CK routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

The breadth of Eigen functionality that can be substituted is listed in the table below. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{3}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Functional domain}&\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ B\+L\+A\+S/\+L\+A\+P\+A\+CK routines }\\\cline{1-3}
\endhead
Matrix-\/matrix operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1*m2.transpose();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>()*m2;}
\DoxyCodeLine{m1*m2.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>();}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>().rankUpdate(m2,1.0);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemm}
\DoxyCodeLine{?symm/?hemm}
\DoxyCodeLine{?trmm}
\DoxyCodeLine{dsyrk/ssyrk}
\end{DoxyCode}
 \\\cline{1-3}
Matrix-\/vector operations ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.adjoint()*b;}
\DoxyCodeLine{m1.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdaf581029282d421eee5aae14238c6f749}{Lower}}>()*b;}
\DoxyCodeLine{m1.triangularView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>()*b;}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gemv}
\DoxyCodeLine{?symv/?hemv}
\DoxyCodeLine{?trmv}
\end{DoxyCode}
 \\\cline{1-3}
LU decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m1.lu().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?getrf}
\end{DoxyCode}
 \\\cline{1-3}
Cholesky decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{v1 = m2.selfadjointView<\mbox{\hyperlink{group__enums_gga39e3366ff5554d731e7dc8bb642f83cdafca2ccebb604f171656deb53e8c083c1}{Upper}}>().llt().solve(v2);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
QR decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.householderQr();}
\DoxyCodeLine{m1.colPivHouseholderQr();}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?geqrf}
\DoxyCodeLine{?geqp3}
\end{DoxyCode}
 \\\cline{1-3}
Singular value decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &
\begin{DoxyCode}{0}
\DoxyCodeLine{JacobiSVD<MatrixXd> svd;}
\DoxyCodeLine{svd.compute(m1, \mbox{\hyperlink{group__enums_ggae3e239fb70022eb8747994cf5d68b4a9a540036417bfecf2e791a70948c227f47}{ComputeThinV}});}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gesvd}
\end{DoxyCode}
 \\\cline{1-3}
Eigen-\/value decompositions ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{EigenSolver<MatrixXd> es(m1);}
\DoxyCodeLine{ComplexEigenSolver<MatrixXcd> ces(m1);}
\DoxyCodeLine{SelfAdjointEigenSolver<MatrixXd> saes(m1+m1.transpose());}
\DoxyCodeLine{GeneralizedSelfAdjointEigenSolver<MatrixXd>}
\DoxyCodeLine{    gsaes(m1+m1.transpose(),m2+m2.transpose());}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?gees}
\DoxyCodeLine{?syev/?heev}
\DoxyCodeLine{?syev/?heev,}
\DoxyCodeLine{?potrf}
\end{DoxyCode}
 \\\cline{1-3}
Schur decomposition ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} ~\newline
 {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &
\begin{DoxyCode}{0}
\DoxyCodeLine{RealSchur<MatrixXd> schurR(m1);}
\DoxyCodeLine{ComplexSchur<MatrixXcd> schurC(m1);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{?gees}
\end{DoxyCode}
 \\\cline{1-3}
\end{longtabu}
In the examples, m1 and m2 are dense matrices and v1 and v2 are dense vectors. \hypertarget{TopicUsingIntelMKL}{}\doxysection{Using IntelÂ® M\+KL from Eigen}\label{TopicUsingIntelMKL}
Since Eigen version 3.\+1 and later, users can benefit from built-\/in IntelÂ® Math Kernel Library (M\+KL) optimizations with an installed copy of Intel M\+KL 10.\+3 (or later).

\href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ Intel M\+KL }} provides highly optimized multi-\/threaded mathematical routines for~x86-\/compatible architectures. Intel M\+KL is available on Linux, Mac and Windows for both Intel64 and I\+A32 architectures.

\begin{DoxyNote}{Note}
IntelÂ® M\+KL is a proprietary software and it is the responsibility of users to buy or register for community (free) Intel M\+KL licenses for their products. Moreover, the license of the user product has to allow linking to proprietary software that excludes any unmodified versions of the G\+PL.
\end{DoxyNote}
Using Intel M\+KL through Eigen is easy\+:
\begin{DoxyEnumerate}
\item define the {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} macro before including any Eigen\textquotesingle{}s header
\item link your program to M\+KL libraries (see the \href{http://software.intel.com/en-us/articles/intel-mkl-link-line-advisor/}{\texttt{ M\+KL linking advisor}})
\item on a 64bits system, you must use the L\+P64 interface (not the I\+L\+P64 one)
\end{DoxyEnumerate}

When doing so, a number of Eigen\textquotesingle{}s algorithms are silently substituted with calls to Intel M\+KL routines. These substitutions apply only for {\bfseries{Dynamic}} {\bfseries{or}} {\bfseries{large}} enough objects with one of the following four standard scalar types\+: {\ttfamily float}, {\ttfamily double}, {\ttfamily complex$<$float$>$}, and {\ttfamily complex$<$double$>$}. Operations on other scalar types or mixing reals and complexes will continue to use the built-\/in algorithms.

In addition you can choose which parts will be substituted by defining one or multiple of the following macros\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS} &Enables the use of external B\+L\+AS level 2 and 3 routines \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} &Enables the use of external Lapack routines via the \href{http://www.netlib.org/lapack/lapacke.html}{\texttt{ Lapacke}} C interface to Lapack \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+K\+E\+\_\+\+S\+T\+R\+I\+CT} &Same as {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE} but algorithm of lower robustness are disabled. ~\newline
 This currently concerns only \mbox{\hyperlink{class_eigen_1_1_jacobi_s_v_d}{Jacobi\+S\+VD}} which otherwise would be replaced by {\ttfamily gesvd} that is less robust than Jacobi rotations. \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML} &Enables the use of Intel V\+ML (vector operations) \\\cline{1-2}
{\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+A\+LL} &Defines {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+B\+L\+AS}, {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+L\+A\+P\+A\+C\+KE}, and {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML}  \\\cline{1-2}
\end{longtabu}


The options can be combined with {\bfseries{M\+K\+L\+\_\+\+D\+I\+R\+E\+C\+T\+\_\+\+C\+A\+LL}} to enable M\+KL direct call feature. This may help to increase performance of some M\+KL B\+L\+AS (?G\+E\+MM, ?G\+E\+MV, ?T\+R\+SM, ?A\+X\+PY and ?D\+OT) and L\+A\+P\+A\+CK (LU, Cholesky and QR) routines for very small matrices. To make it work properly, the macro {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+KL} must also be defined in the case none of the other {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+$\ast$} macros has been defined.

Note that the B\+L\+AS and L\+A\+P\+A\+C\+KE backends can be enabled for any F77 compatible B\+L\+AS and L\+A\+P\+A\+CK libraries. See this \mbox{\hyperlink{_topic_using_blas_lapack}{page }} for the details.

Finally, the P\+A\+R\+D\+I\+SO sparse solver shipped with Intel M\+KL can be used through the \mbox{\hyperlink{class_eigen_1_1_pardiso_l_u}{Pardiso\+LU}}, \mbox{\hyperlink{class_eigen_1_1_pardiso_l_l_t}{Pardiso\+L\+LT}} and \mbox{\hyperlink{class_eigen_1_1_pardiso_l_d_l_t}{Pardiso\+L\+D\+LT}} classes of the Pardiso\+Support\+\_\+\+Module.

The following table summarizes the list of functions covered by {\ttfamily E\+I\+G\+E\+N\+\_\+\+U\+S\+E\+\_\+\+M\+K\+L\+\_\+\+V\+ML\+:} \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Code example}&\cellcolor{\tableheadbgcolor}\textbf{ M\+KL routines }\\\cline{1-2}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{v2=v1.array().sin();}
\DoxyCodeLine{v2=v1.array().asin();}
\DoxyCodeLine{v2=v1.array().cos();}
\DoxyCodeLine{v2=v1.array().acos();}
\DoxyCodeLine{v2=v1.array().tan();}
\DoxyCodeLine{v2=v1.array().exp();}
\DoxyCodeLine{v2=v1.array().log();}
\DoxyCodeLine{v2=v1.array().sqrt();}
\DoxyCodeLine{v2=v1.array().square();}
\DoxyCodeLine{v2=v1.array().pow(1.5);}
\end{DoxyCode}
&
\begin{DoxyCode}{0}
\DoxyCodeLine{v?Sin}
\DoxyCodeLine{v?Asin}
\DoxyCodeLine{v?Cos}
\DoxyCodeLine{v?Acos}
\DoxyCodeLine{v?Tan}
\DoxyCodeLine{v?Exp}
\DoxyCodeLine{v?Ln}
\DoxyCodeLine{v?Sqrt}
\DoxyCodeLine{v?Sqr}
\DoxyCodeLine{v?Powx}
\end{DoxyCode}
 \\\cline{1-2}
\end{longtabu}
In the examples, v1 and v2 are dense vectors.\hypertarget{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}{}\doxysubsection{Links}\label{_topic_using_intel_m_k_l_TopicUsingIntelMKL_Links}

\begin{DoxyItemize}
\item Intel M\+KL can be purchased and downloaded \href{http://eigen.tuxfamily.org/Counter/redirect_to_mkl.php}{\texttt{ here}}.
\item Intel M\+KL is also bundled with \href{http://software.intel.com/en-us/articles/intel-composer-xe/}{\texttt{ Intel Composer XE}}. 
\end{DoxyItemize}\hypertarget{TopicCUDA}{}\doxysection{Using Eigen in C\+U\+DA kernels}\label{TopicCUDA}
{\bfseries{Disclaimer\+:}} this page is about an {\bfseries{experimental}} feature in Eigen.

Staring from C\+U\+DA 5.\+0, the C\+U\+DA compiler, {\ttfamily nvcc}, is able to properly parse Eigen\textquotesingle{}s code (almost). A few adaptations of the Eigen\textquotesingle{}s code already allows to use some parts of Eigen in your own C\+U\+DA kernels. To this end you need the devel branch of Eigen, C\+U\+DA 5.\+0 or greater with G\+CC.

Known issues\+:


\begin{DoxyItemize}
\item {\ttfamily nvcc} with MS Visual Studio does not work (patch welcome)
\item {\ttfamily nvcc} with {\ttfamily clang} does not work (patch welcome)
\item {\ttfamily nvcc} 5.\+5 with gcc-\/4.\+7 (or greater) has issues with the standard {\ttfamily $<$limits$>$} header file. To workaround this, you can add the following before including any other files\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// workaround issue between gcc >= 4.7 and cuda 5.5}}
\DoxyCodeLine{\textcolor{preprocessor}{\#if (defined \_\_GNUC\_\_) \&\& (\_\_GNUC\_\_>4 || \_\_GNUC\_MINOR\_\_>=7)}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_ATOMIC\_BUILTINS}}
\DoxyCodeLine{\textcolor{preprocessor}{  \#undef \_GLIBCXX\_USE\_INT128}}
\DoxyCodeLine{\textcolor{preprocessor}{\#endif}}
\end{DoxyCode}

\item On 64bits system \mbox{\hyperlink{namespace_eigen}{Eigen}} uses {\ttfamily long} {\ttfamily int} as the default type for indexes and sizes. On C\+U\+DA device, it would make sense to default to 32 bits {\ttfamily int}. However, to keep host and C\+U\+DA code compatible, this cannot be done automatically by Eigen, and the user is thus required to define {\ttfamily E\+I\+G\+E\+N\+\_\+\+D\+E\+F\+A\+U\+L\+T\+\_\+\+D\+E\+N\+S\+E\+\_\+\+I\+N\+D\+E\+X\+\_\+\+T\+Y\+PE} to {\ttfamily int} throughout his code (or only for C\+U\+DA code if there is no interaction between host and C\+U\+DA code through Eigen\textquotesingle{}s object). 
\end{DoxyItemize}\hypertarget{TopicPitfalls}{}\doxysection{Common pitfalls}\label{TopicPitfalls}
\hypertarget{_topic_pitfalls_TopicPitfalls_template_keyword}{}\doxysubsection{Compilation error with template methods}\label{_topic_pitfalls_TopicPitfalls_template_keyword}
See this \mbox{\hyperlink{_topic_template_keyword}{page }}.\hypertarget{_topic_pitfalls_TopicPitfalls_aliasing}{}\doxysubsection{Aliasing}\label{_topic_pitfalls_TopicPitfalls_aliasing}
Don\textquotesingle{}t miss this \mbox{\hyperlink{group___topic_aliasing}{page }} on aliasing, especially if you got wrong results in statements where the destination appears on the right hand side of the expression.\hypertarget{_topic_pitfalls_TopicPitfalls_auto_keyword}{}\doxysubsection{C++11 and the auto keyword}\label{_topic_pitfalls_TopicPitfalls_auto_keyword}
In short\+: do not use the auto keywords with \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s expressions, unless you are 100\% sure about what you are doing. In particular, do not use the auto keyword as a replacement for a Matrix$<$$>$ type. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixXd A, B;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = A*B;}
\DoxyCodeLine{\textcolor{keywordflow}{for}(...) \{ ... w = C * v;  ...\}}
\end{DoxyCode}


In this example, the type of C is not a Matrix\+Xd but an abstract expression representing a matrix product and storing references to A and B. Therefore, the product of A$\ast$B will be carried out multiple times, once per iteration of the for loop. Moreover, if the coefficients of A or B change during the iteration, then C will evaluate to different values.

Here is another example leading to a segfault\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = ((A+B).eval()).transpose();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 The problem is that eval() returns a temporary object (in this case a Matrix\+Xd) which is then referenced by the Transpose$<$$>$ expression. However, this temporary is deleted right after the first line, and there the C expression reference a dead object. The same issue might occur when sub expressions are automatically evaluated by \mbox{\hyperlink{namespace_eigen}{Eigen}} as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXd u, v;}
\DoxyCodeLine{\textcolor{keyword}{auto} C = u + (A*v).normalized();}
\DoxyCodeLine{\textcolor{comment}{// do something with C}}
\end{DoxyCode}
 where the normalized() method has to evaluate the expensive product A$\ast$v to avoid evaluating it twice. On the other hand, the following example is perfectly fine\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{auto} C = (u + (A*v).normalized()).eval();}
\end{DoxyCode}
 In this case, C will be a regular Vector\+Xd object. \hypertarget{TopicTemplateKeyword}{}\doxysection{The template and typename keywords in C++}\label{TopicTemplateKeyword}
There are two uses for the {\ttfamily template} and {\ttfamily typename} keywords in C++. One of them is fairly well known amongst programmers\+: to define templates. The other use is more obscure\+: to specify that an expression refers to a template function or a type. This regularly trips up programmers that use the Eigen library, often leading to error messages from the compiler that are difficult to understand, such as \char`\"{}expected expression\char`\"{} or \char`\"{}no match for operator$<$\char`\"{}.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}{}\doxysubsection{Using the template and typename keywords to define templates}\label{_topic_template_keyword_TopicTemplateKeywordToDefineTemplates}
The {\ttfamily template} and {\ttfamily typename} keywords are routinely used to define templates. This is not the topic of this page as we assume that the reader is aware of this (otherwise consult a C++ book). The following example should illustrate this use of the {\ttfamily template} keyword.


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{bool} isPositive(\mbox{\hyperlink{class_eigen_1_1_triplet}{T}} x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{    \textcolor{keywordflow}{return} x > 0;}
\DoxyCodeLine{\}}
\end{DoxyCode}


We could just as well have written {\ttfamily template $<$class T$>$}; the keywords {\ttfamily typename} and {\ttfamily class} have the same meaning in this context.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExample}{}\doxysubsection{An example showing the second use of the template keyword}\label{_topic_template_keyword_TopicTemplateKeywordExample}
Let us illustrate the second use of the {\ttfamily template} keyword with an example. Suppose we want to write a function which copies all entries in the upper triangular part of a matrix into another matrix, while keeping the lower triangular part unchanged. A straightforward implementation would be as follows\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


That works fine, but it is not very flexible. First, it only works with dynamic-\/size matrices of single-\/precision floats; the function {\ttfamily copy\+Upper\+Triangular\+Part()} does not accept static-\/size matrices or matrices with double-\/precision numbers. Second, if you use an expression such as {\ttfamily mat.\+top\+Left\+Corner(3,3)} as the parameter {\ttfamily src}, then this is copied into a temporary variable of type Matrix\+Xf; this copy can be avoided.

As explained in \mbox{\hyperlink{TopicFunctionTakingEigenTypes}{Writing Functions Taking Eigen Types as Parameters}}, both issues can be resolved by making {\ttfamily copy\+Upper\+Triangular\+Part()} accept any object of type \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This leads to the following code\+:

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Example\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Output\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyVerbInclude}
\end{DoxyVerbInclude}
 \\\cline{1-2}
\end{longtabu}


The one line in the body of the function {\ttfamily copy\+Upper\+Triangular\+Part()} shows the second, more obscure use of the {\ttfamily template} keyword in C++. Even though it may look strange, the {\ttfamily template} keywords are necessary according to the standard. Without it, the compiler may reject the code with an error message like \char`\"{}no match
for operator$<$\char`\"{}.\hypertarget{_topic_template_keyword_TopicTemplateKeywordExplanation}{}\doxysubsection{Explanation}\label{_topic_template_keyword_TopicTemplateKeywordExplanation}
The reason that the {\ttfamily template} keyword is necessary in the last example has to do with the rules for how templates are supposed to be compiled in C++. The compiler has to check the code for correct syntax at the point where the template is defined, without knowing the actual value of the template arguments ({\ttfamily Derived1} and {\ttfamily Derived2} in the example). That means that the compiler cannot know that {\ttfamily dst.\+triangular\+View} is a member template and that the following $<$ symbol is part of the delimiter for the template parameter. Another possibility would be that {\ttfamily dst.\+triangular\+View} is a member variable with the $<$ symbol refering to the {\ttfamily operator$<$()} function. In fact, the compiler should choose the second possibility, according to the standard. If {\ttfamily dst.\+triangular\+View} is a member template (as in our case), the programmer should specify this explicitly with the {\ttfamily template} keyword and write {\ttfamily dst.\+template triangular\+View}.

The precise rules are rather complicated, but ignoring some subtleties we can summarize them as follows\+:
\begin{DoxyItemize}
\item A {\itshape dependent name} is name that depends (directly or indirectly) on a template parameter. In the example, {\ttfamily dst} is a dependent name because it is of type {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Derived1$>$} which depends on the template parameter {\ttfamily Derived1}.
\item If the code contains either one of the constructs {\ttfamily xxx.\+yyy} or {\ttfamily xxx-\/$>$yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member template, then the {\ttfamily template} keyword must be used before {\ttfamily yyy}, leading to {\ttfamily xxx.\+template yyy} or {\ttfamily xxx-\/$>$template yyy}.
\item If the code contains the construct {\ttfamily xxx\+::yyy} and {\ttfamily xxx} is a dependent name and {\ttfamily yyy} refers to a member typedef, then the {\ttfamily typename} keyword must be used before the whole construct, leading to {\ttfamily typename xxx\+::yyy}.
\end{DoxyItemize}

As an example where the {\ttfamily typename} keyword is required, consider the following code in \mbox{\hyperlink{group___tutorial_sparse}{Tutorial\+Sparse}} for iterating over the non-\/zero entries of a sparse matrix type\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{SparseMatrixType mat(rows,cols);}
\DoxyCodeLine{\textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<mat.outerSize(); ++k)}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (SparseMatrixType::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{comment}{/* ... */}}
\DoxyCodeLine{  \}}
\end{DoxyCode}


If {\ttfamily Sparse\+Matrix\+Type} depends on a template parameter, then the {\ttfamily typename} keyword is required\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template} <\textcolor{keyword}{typename} T>}
\DoxyCodeLine{\textcolor{keywordtype}{void} iterateOverSparseMatrix(\textcolor{keyword}{const} SparseMatrix<T>\& mat;}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} k=0; k<m1.outerSize(); ++k)}
\DoxyCodeLine{    \textcolor{keywordflow}{for} (\textcolor{keyword}{typename} SparseMatrix<T>::InnerIterator it(mat,k); it; ++it)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      \textcolor{comment}{/* ... */}}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\}}
\end{DoxyCode}
\hypertarget{_topic_template_keyword_TopicTemplateKeywordResources}{}\doxysubsection{Resources for further reading}\label{_topic_template_keyword_TopicTemplateKeywordResources}
For more information and a fuller explanation of this topic, the reader may consult the following sources\+:
\begin{DoxyItemize}
\item The book \char`\"{}\+C++ Template Metaprogramming\char`\"{} by David Abrahams and Aleksey Gurtovoy contains a very good explanation in Appendix B (\char`\"{}\+The typename and template Keywords\char`\"{}) which formed the basis for this page.
\item \href{http://pages.cs.wisc.edu/~driscoll/typename.html}{\texttt{ http\+://pages.\+cs.\+wisc.\+edu/$\sim$driscoll/typename.\+html}}
\item \href{http://www.parashift.com/c++-faq-lite/templates.html\#faq-35.18}{\texttt{ http\+://www.\+parashift.\+com/c++-\/faq-\/lite/templates.\+html\#faq-\/35.\+18}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#templateprefix}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#templateprefix}}
\item \href{http://www.comeaucomputing.com/techtalk/templates/\#typename}{\texttt{ http\+://www.\+comeaucomputing.\+com/techtalk/templates/\#typename}} 
\end{DoxyItemize}\hypertarget{UserManual_UnderstandingEigen}{}\doxysection{Understanding Eigen}\label{UserManual_UnderstandingEigen}

\begin{DoxyItemize}
\item \mbox{\hyperlink{TopicInsideEigenExample}{What happens inside Eigen, on a simple example}}
\item \mbox{\hyperlink{TopicClassHierarchy}{The class hierarchy}}
\item \mbox{\hyperlink{TopicLazyEvaluation}{Lazy Evaluation and Aliasing}} 
\end{DoxyItemize}\hypertarget{TopicInsideEigenExample}{}\doxysubsection{What happens inside Eigen, on a simple example}\label{TopicInsideEigenExample}
\textbackslash{}eigen\+Auto\+Toc

\DoxyHorRuler{0}


Consider the following example program\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{preprocessor}{\#include<Eigen/Core>}}
\DoxyCodeLine{}
\DoxyCodeLine{\textcolor{keywordtype}{int} main()}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordtype}{int} size = 50;}
\DoxyCodeLine{  \textcolor{comment}{// VectorXf is a vector of floats, with dynamic size.}}
\DoxyCodeLine{  Eigen::VectorXf u(size), v(size), w(size);}
\DoxyCodeLine{  u = v + w;}
\DoxyCodeLine{\}}
\end{DoxyCode}


The goal of this page is to understand how \mbox{\hyperlink{namespace_eigen}{Eigen}} compiles it, assuming that S\+S\+E2 vectorization is enabled (G\+CC option -\/msse2).\hypertarget{_topic_inside_eigen_example_WhyInteresting}{}\doxysubsubsection{Why it\textquotesingle{}s interesting}\label{_topic_inside_eigen_example_WhyInteresting}
Maybe you think, that the above example program is so simple, that compiling it shouldn\textquotesingle{}t involve anything interesting. So before starting, let us explain what is nontrivial in compiling it correctly -- that is, producing optimized code -- so that the complexity of \mbox{\hyperlink{namespace_eigen}{Eigen}}, that we\textquotesingle{}ll explain here, is really useful.

Look at the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;   \textcolor{comment}{//   (*)}}
\end{DoxyCode}


The first important thing about compiling it, is that the arrays should be traversed only once, like 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}
 The problem is that if we make a naive C++ library where the Vector\+Xf class has an operator+ returning a Vector\+Xf, then the line of code ($\ast$) will amount to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf tmp = v + w;}
\DoxyCodeLine{VectorXf u = tmp;}
\end{DoxyCode}
 Obviously, the introduction of the temporary {\itshape tmp} here is useless. It has a very bad effect on performance, first because the creation of {\itshape tmp} requires a dynamic memory allocation in this context, and second as there are now two for loops\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) tmp[i] = v[i] + w[i];}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < size; i++) u[i] = tmp[i];}
\end{DoxyCode}
 Traversing the arrays twice instead of once is terrible for performance, as it means that we do many redundant memory accesses.

The second important thing about compiling the above program, is to make correct use of S\+S\+E2 instructions. Notice that \mbox{\hyperlink{namespace_eigen}{Eigen}} also supports Alti\+Vec and that all the discussion that we make here applies also to Alti\+Vec.

S\+S\+E2, like Alti\+Vec, is a set of instructions allowing to perform computations on packets of 128 bits at once. Since a float is 32 bits, this means that S\+S\+E2 instructions can handle 4 floats at once. This means that, if correctly used, they can make our computation go up to 4x faster.

However, in the above program, we have chosen size=50, so our vectors consist of 50 float\textquotesingle{}s, and 50 is not a multiple of 4. This means that we cannot hope to do all of that computation using S\+S\+E2 instructions. The second best thing, to which we should aim, is to handle the 48 first coefficients with S\+S\+E2 instructions, since 48 is the biggest multiple of 4 below 50, and then handle separately, without S\+S\+E2, the 49th and 50th coefficients. Something like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < 4*(size/4); i+=4) u.packet(i)  = v.packet(i) + w.packet(i);}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 4*(size/4); i < size; i++) u[i] = v[i] + w[i];}
\end{DoxyCode}


So let us look line by line at our example program, and let\textquotesingle{}s follow \mbox{\hyperlink{namespace_eigen}{Eigen}} as it compiles it.\hypertarget{_topic_inside_eigen_example_ConstructingVectors}{}\doxysubsubsection{Constructing vectors}\label{_topic_inside_eigen_example_ConstructingVectors}
Let\textquotesingle{}s analyze the first line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size), v(size), w(size);}
\end{DoxyCode}


First of all, Vector\+Xf is the following typedef\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typedef} Matrix<float, Dynamic, 1> VectorXf;}
\end{DoxyCode}


The class template \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} is declared in \mbox{\hyperlink{_forward_declarations_8h_source}{src/\+Core/util/\+Forward\+Declarations.\+h}} with 6 template parameters, but the last 3 are automatically determined by the first 3. So you don\textquotesingle{}t need to worry about them for now. Here, \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$float, Dynamic, 1$>$ means a matrix of floats, with a dynamic number of rows and 1 column.

The \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class inherits a base class, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Don\textquotesingle{}t worry about it, for now it suffices to say that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is what unifies matrices/vectors and all the expressions types -- more on that below.

When we do 
\begin{DoxyCode}{0}
\DoxyCodeLine{Eigen::VectorXf u(size);}
\end{DoxyCode}
 the constructor that is called is Matrix\+::\+Matrix(int), in \mbox{\hyperlink{_matrix_8h_source}{src/\+Core/\+Matrix.\+h}}. Besides some assertions, all it does is to construct the {\itshape m\+\_\+storage} member, which is of type \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}$<$float, Dynamic, Dynamic, 1$>$.

You may wonder, isn\textquotesingle{}t it overengineering to have the storage in a separate class? The reason is that the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class template covers all kinds of matrices and vector\+: both fixed-\/size and dynamic-\/size. The storage method is not the same in these two cases. For fixed-\/size, the matrix coefficients are stored as a plain member array. For dynamic-\/size, the coefficients will be stored as a pointer to a dynamically-\/allocated array. Because of this, we need to abstract storage away from the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. That\textquotesingle{}s \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}.

Let\textquotesingle{}s look at this constructor, in \mbox{\hyperlink{_dense_storage_8h_source}{src/\+Core/\+Dense\+Storage.\+h}}. You can see that there are many partial template specializations of Dense\+Storages here, treating separately the cases where dimensions are Dynamic or fixed at compile-\/time. The partial specialization that we are looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T, \textcolor{keywordtype}{int} \_Cols> \textcolor{keyword}{class }DenseStorage<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \mbox{\hyperlink{namespace_eigen_ad81fa7195215a0ce30017dfac309f0b2}{Dynamic}}, \_Cols>}
\end{DoxyCode}


Here, the constructor called is Dense\+Storage\+::\+Dense\+Storage(int size, int rows, int columns) with size=50, rows=50, columns=1.

Here is this constructor\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{inline} DenseStorage(\textcolor{keywordtype}{int} size, \textcolor{keywordtype}{int} rows, \textcolor{keywordtype}{int}) : m\_data(internal::aligned\_new<\mbox{\hyperlink{class_eigen_1_1_triplet}{T}}>(size)), m\_rows(rows) \{\}}
\end{DoxyCode}


Here, the {\itshape m\+\_\+data} member is the actual array of coefficients of the matrix. As you see, it is dynamically allocated. Rather than calling new\mbox{[}\mbox{]} or malloc(), as you can see, we have our own internal\+::aligned\+\_\+new defined in \mbox{\hyperlink{_memory_8h_source}{src/\+Core/util/\+Memory.\+h}}. What it does is that if vectorization is enabled, then it uses a platform-\/specific call to allocate a 128-\/bit-\/aligned array, as that is very useful for vectorization with both S\+S\+E2 and Alti\+Vec. If vectorization is disabled, it amounts to the standard new\mbox{[}\mbox{]}.

As you can see, the constructor also sets the {\itshape m\+\_\+rows} member to {\itshape size}. Notice that there is no {\itshape m\+\_\+columns} member\+: indeed, in this partial specialization of \mbox{\hyperlink{class_eigen_1_1_dense_storage}{Dense\+Storage}}, we know the number of columns at compile-\/time, since the \+\_\+\+Cols template parameter is different from Dynamic. Namely, in our case, \+\_\+\+Cols is 1, which is to say that our vector is just a matrix with 1 column. Hence, there is no need to store the number of columns as a runtime variable.

When you call Vector\+Xf\+::data() to get the pointer to the array of coefficients, it returns Dense\+Storage\+::data() which returns the {\itshape m\+\_\+data} member.

When you call Vector\+Xf\+::size() to get the size of the vector, this is actually a method in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. It determines that the vector is a column-\/vector, since Cols\+At\+Compile\+Time==1 (this comes from the template parameters in the typedef Vector\+Xf). It deduces that the size is the number of rows, so it returns Vector\+Xf\+::rows(), which returns Dense\+Storage\+::rows(), which returns the {\itshape m\+\_\+rows} member, which was set to {\itshape size} by the constructor.\hypertarget{_topic_inside_eigen_example_ConstructionOfSumXpr}{}\doxysubsubsection{Construction of the sum expression}\label{_topic_inside_eigen_example_ConstructionOfSumXpr}
Now that our vectors are constructed, let\textquotesingle{}s move on to the next line\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}


The executive summary is that operator+ returns a \char`\"{}sum of vectors\char`\"{} expression, but doesn\textquotesingle{}t actually perform the computation. It is the operator=, whose call occurs thereafter, that does the computation.

Let us now see what \mbox{\hyperlink{namespace_eigen}{Eigen}} does when it sees this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Here, v and w are of type Vector\+Xf, which is a typedef for a specialization of \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} (as we explained above), which is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So what is being called is


\begin{DoxyCode}{0}
\DoxyCodeLine{MatrixBase::operator+(\textcolor{keyword}{const} MatrixBase\&)}
\end{DoxyCode}


The return type of this operator is 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 The \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class is our first encounter with an expression template. As we said, the operator+ doesn\textquotesingle{}t by itself perform any computation, it just returns an abstract \char`\"{}sum of vectors\char`\"{} expression. Since there are also \char`\"{}difference of vectors\char`\"{} and \char`\"{}coefficient-\/wise product of vectors\char`\"{} expressions, we unify them all as \char`\"{}coefficient-\/wise binary operations\char`\"{}, which we abbreviate as \char`\"{}\+Cwise\+Binary\+Op\char`\"{}. \char`\"{}\+Coefficient-\/wise\char`\"{} means that the operations is performed coefficient by coefficient. \char`\"{}binary\char`\"{} means that there are two operands -- we are adding two vectors with one another.

Now you might ask, what if we did something like


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w + u;}
\end{DoxyCode}


The first v + w would return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} as above, so in order for this to compile, we\textquotesingle{}d need to define an operator+ also in the class \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}... at this point it starts looking like a nightmare\+: are we going to have to define all operators in each of the expression classes (as you guessed, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is only one of many) ? This looks like a dead end!

The solution is that \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} itself, as well as \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} and all the other expression types, is a subclass of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. So it is enough to define once and for all the operators in class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}.

Since \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is the common base class of different subclasses, the aspects that depend on the subclass must be abstracted from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. This is called polymorphism.

The classical approach to polymorphism in C++ is by means of virtual functions. This is dynamic polymorphism. Here we don\textquotesingle{}t want dynamic polymorphism because the whole design of \mbox{\hyperlink{namespace_eigen}{Eigen}} is based around the assumption that all the complexity, all the abstraction, gets resolved at compile-\/time. This is crucial\+: if the abstraction can\textquotesingle{}t get resolved at compile-\/time, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s compile-\/time optimization mechanisms become useless, not to mention that if that abstraction has to be resolved at runtime it\textquotesingle{}ll incur an overhead by itself.

Here, what we want is to have a single class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} as the base of many subclasses, in such a way that each \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} object (be it a matrix, or vector, or any kind of expression) knows at compile-\/time (as opposed to run-\/time) of which particular subclass it is an object (i.\+e. whether it is a matrix, or an expression, and what kind of expression).

The solution is the \href{http://en.wikipedia.org/wiki/Curiously_Recurring_Template_Pattern}{\texttt{ Curiously Recurring Template Pattern}}. Let\textquotesingle{}s do the break now. Hopefully you can read this wikipedia page during the break if needed, but it won\textquotesingle{}t be allowed during the exam.

In short, \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} takes a template parameter {\itshape Derived}. Whenever we define a subclass Subclass, we actually make Subclass inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$Subclass$>$. The point is that different subclasses inherit different \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} types. Thanks to this, whenever we have an object of a subclass, and we call on it some \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method, we still remember even from inside the \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} method which particular subclass we\textquotesingle{}re talking about.

This means that we can put almost all the methods and operators in the base class \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, and have only the bare minimum in the subclasses. If you look at the subclasses in \mbox{\hyperlink{namespace_eigen}{Eigen}}, like for instance the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} class, they have very few methods. There are coeff() and sometimes coeff\+Ref() methods for access to the coefficients, there are rows() and cols() methods returning the number of rows and columns, but there isn\textquotesingle{}t much more than that. All the meat is in \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}, so it only needs to be coded once for all kinds of expressions, matrices, and vectors.

So let\textquotesingle{}s end this digression and come back to the piece of code from our example program that we were currently analyzing,


\begin{DoxyCode}{0}
\DoxyCodeLine{v + w}
\end{DoxyCode}


Now that \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} is a good friend, let\textquotesingle{}s write fully the prototype of the operator+ that gets called here (this code is from \mbox{\hyperlink{_matrix_base_8h_source}{src/\+Core/\+Matrix\+Base.\+h}})\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<typename internal::traits<Derived>::Scalar>, Derived, OtherDerived>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<OtherDerived> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here of course, {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf.

As we said, \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is also used for other operations such as substration, so it takes another template parameter determining the operation that will be applied to coefficients. This template parameter is a functor, that is, a class in which we have an operator() so it behaves like a function. Here, the functor used is \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}}. It is defined in src/\+Core/\+Functors.\+h.

Let us now explain the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} here. The \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} class takes one template parameter\+: the type of the numbers to handle. Here of course we want to pass the scalar type (a.\+k.\+a. numeric type) of Vector\+Xf, which is {\ttfamily float}. How do we determine which is the scalar type of {\itshape Derived} ? Throughout \mbox{\hyperlink{namespace_eigen}{Eigen}}, all matrix and expression types define a typedef {\itshape Scalar} which gives its scalar type. For example, Vector\+Xf\+::\+Scalar is a typedef for {\ttfamily float}. So here, if life was easy, we could find the numeric type of {\itshape Derived} as just 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{typename} Derived::Scalar}
\end{DoxyCode}
 Unfortunately, we can\textquotesingle{}t do that here, as the compiler would complain that the type Derived hasn\textquotesingle{}t yet been defined. So we use a workaround\+: in \mbox{\hyperlink{_forward_declarations_8h_source}{src/\+Core/util/\+Forward\+Declarations.\+h}}, we declared (not defined!) all our subclasses, like \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, and we also declared the following class template\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} T> \textcolor{keyword}{struct }internal::traits;}
\end{DoxyCode}
 In \mbox{\hyperlink{_matrix_8h_source}{src/\+Core/\+Matrix.\+h}}, right {\itshape before} the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we define a partial specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} for T=\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$<$any template parameters$>$. In this specialization of \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}, we define the Scalar typedef. So when we actually define \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, it is legal to refer to \char`\"{}typename internal\+::traits\textbackslash{}$<$\+Matrix\textbackslash{}$>$\+::\+Scalar\char`\"{}.

Anyway, we have declared our operator+. In our case, where {\itshape Derived} and {\itshape Other\+Derived} are Vector\+Xf, the above declaration amounts to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }MatrixBase<VectorXf>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{keyword}{const} CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\DoxyCodeLine{  operator+(\textcolor{keyword}{const} MatrixBase<VectorXf> \&other) \textcolor{keyword}{const};}
\DoxyCodeLine{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Let\textquotesingle{}s now jump to \mbox{\hyperlink{_cwise_binary_op_8h_source}{src/\+Core/\+Cwise\+Binary\+Op.\+h}} to see how it is defined. As you can see there, all it does is to return a \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object, and this object is just storing references to the left-\/hand-\/side and right-\/hand-\/side expressions -- here, these are the vectors {\itshape v} and {\itshape w}. Well, the \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} object is also storing an instance of the (empty) functor class, but you shouldn\textquotesingle{}t worry about it as that is a minor implementation detail.

Thus, the operator+ hasn\textquotesingle{}t performed any actual computation. To summarize, the operation {\itshape v} + {\itshape w} just returned an object of type \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} which did nothing else than just storing references to {\itshape v} and {\itshape w}.\hypertarget{_topic_inside_eigen_example_Assignment}{}\doxysubsubsection{The assignment}\label{_topic_inside_eigen_example_Assignment}
At this point, the expression {\itshape v} + {\itshape w} has finished evaluating, so, in the process of compiling the line of code 
\begin{DoxyCode}{0}
\DoxyCodeLine{u = v + w;}
\end{DoxyCode}
 we now enter the operator=.

What operator= is being called here? The vector u is an object of class Vector\+Xf, i.\+e. \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}. In \mbox{\hyperlink{_matrix_8h_source}{src/\+Core/\+Matrix.\+h}}, inside the definition of class \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}, we see this\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Matrix\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_assert(m\_storage.data()!=0 \&\& \textcolor{stringliteral}{"you cannot use operator= with a non initialized matrix (instead use set()"});}
\DoxyCodeLine{  \textcolor{keywordflow}{return} Base::operator=(other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, Base is a typedef for \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$. So, what is being called is the operator= of \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}. Let\textquotesingle{}s see its prototype in \mbox{\hyperlink{_matrix_base_8h_source}{src/\+Core/\+Matrix\+Base.\+h}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{Derived\& operator=(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other);}
\end{DoxyCode}
 Here, {\itshape Derived} is Vector\+Xf (since u is a Vector\+Xf) and {\itshape Other\+Derived} is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. More specifically, as explained in the previous section, {\itshape Other\+Derived} is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So the full prototype of the operator= being called is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{VectorXf\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<VectorXf>::operator=}}(\textcolor{keyword}{const} MatrixBase<CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf> > \& other);}
\end{DoxyCode}
 This operator= literally reads \char`\"{}copying a sum of two Vector\+Xf\textquotesingle{}s into another Vector\+Xf\char`\"{}.

Let\textquotesingle{}s now look at the implementation of this operator=. It resides in the file \mbox{\hyperlink{_assign_8h_source}{src/\+Core/\+Assign.\+h}}.

What we can see there is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& \mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{MatrixBase<Derived>}}}
\DoxyCodeLine{\mbox{\hyperlink{class_eigen_1_1_matrix_base_a706a4dd1ee54786e9210de1a4bf02600}{  ::operator=}}(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{return} internal::assign\_selector<Derived,OtherDerived>::run(derived(), other.derived());}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK so our next task is to understand internal\+::assign\+\_\+selector \+:)

Here is its declaration (all that is still in the same file \mbox{\hyperlink{_assign_8h_source}{src/\+Core/\+Assign.\+h}}) 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived,}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} EvalBeforeAssigning = int(OtherDerived::Flags) \& \mbox{\hyperlink{group__flags_gae4b8ae7db0d83f9bbed26b261e60e139}{EvalBeforeAssigningBit}},}
\DoxyCodeLine{         \textcolor{keywordtype}{bool} NeedToTranspose = Derived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& OtherDerived::IsVectorAtCompileTime}
\DoxyCodeLine{                \&\& int(Derived::RowsAtCompileTime) == int(OtherDerived::ColsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::ColsAtCompileTime) == int(OtherDerived::RowsAtCompileTime)}
\DoxyCodeLine{                \&\& int(Derived::SizeAtCompileTime) != 1>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector;}
\end{DoxyCode}


So internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

Eval\+Before\+Assigning is here to enforce the Eval\+Before\+Assigning\+Bit. As explained \href{TopicLazyEvaluation.html}{\texttt{ here}}, certain expressions have this flag which makes them automatically evaluate into temporaries before assigning them to another expression. This is the case of the \mbox{\hyperlink{class_eigen_1_1_product}{Product}} expression, in order to avoid strange aliasing effects when doing \char`\"{}m = m $\ast$ m;\char`\"{} However, of course here our \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} expression doesn\textquotesingle{}t have the Eval\+Before\+Assigning\+Bit\+: we said since the beginning that we didn\textquotesingle{}t want a temporary to be introduced here. So if you go to \mbox{\hyperlink{_cwise_binary_op_8h_source}{src/\+Core/\+Cwise\+Binary\+Op.\+h}}, you\textquotesingle{}ll see that the Flags in \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}}$<$\mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}$>$ don\textquotesingle{}t include the Eval\+Before\+Assigning\+Bit. The Flags member of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} is then imported from the \mbox{\hyperlink{struct_eigen_1_1internal_1_1traits}{internal\+::traits}} by the E\+I\+G\+E\+N\+\_\+\+G\+E\+N\+E\+R\+I\+C\+\_\+\+P\+U\+B\+L\+I\+C\+\_\+\+I\+N\+T\+E\+R\+F\+A\+CE macro. Anyway, here the template parameter Eval\+Before\+Assigning has the value {\ttfamily false}.

Need\+To\+Transpose is here for the case where the user wants to copy a row-\/vector into a column-\/vector. We allow this as a special exception to the general rule that in assignments we require the dimesions to match. Anyway, here both the left-\/hand and right-\/hand sides are column vectors, in the sense that Cols\+At\+Compile\+Time is equal to 1. So Need\+To\+Transpose is {\ttfamily false} too.

So, here we are in the partial specialization\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_selector<Derived, OtherDerived, false, false>}
\end{DoxyCode}


Here\textquotesingle{}s how it is defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived, \textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_selector<Derived,OtherDerived,false,false> \{}
\DoxyCodeLine{  \textcolor{keyword}{static} Derived\& run(Derived\& dst, \textcolor{keyword}{const} OtherDerived\& other) \{ \textcolor{keywordflow}{return} dst.lazyAssign(other.derived()); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


OK so now our next job is to understand how lazy\+Assign works \+:)


\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived>}
\DoxyCodeLine{\textcolor{keyword}{inline} Derived\& MatrixBase<Derived>}
\DoxyCodeLine{  ::lazyAssign(\textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  EIGEN\_STATIC\_ASSERT\_SAME\_MATRIX\_SIZE(Derived,OtherDerived)}
\DoxyCodeLine{  eigen\_assert(rows() == other.rows() \&\& cols() == other.cols());}
\DoxyCodeLine{  internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\DoxyCodeLine{  \textcolor{keywordflow}{return} derived();}
\DoxyCodeLine{\}}
\end{DoxyCode}


What do we see here? Some assertions, and then the only interesting line is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived, OtherDerived>::run(derived(),other.derived());}
\end{DoxyCode}


OK so now we want to know what is inside internal\+::assign\+\_\+impl.

Here is its declaration\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Vectorization = internal::assign\_traits<Derived1, Derived2>::Vectorization,}
\DoxyCodeLine{         \textcolor{keywordtype}{int} Unrolling = internal::assign\_traits<Derived1, Derived2>::Unrolling>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl;}
\end{DoxyCode}
 Again, internal\+::assign\+\_\+selector takes 4 template parameters, but the 2 last ones are automatically determined by the 2 first ones.

These two parameters {\itshape Vectorization} and {\itshape Unrolling} are determined by a helper class internal\+::assign\+\_\+traits. Its job is to determine which vectorization strategy to use (that is {\itshape Vectorization}) and which unrolling strategy to use (that is {\itshape Unrolling}).

We\textquotesingle{}ll not enter into the details of how these strategies are chosen (this is in the implementation of internal\+::assign\+\_\+traits at the top of the same file). Let\textquotesingle{}s just say that here {\itshape Vectorization} has the value {\itshape Linear\+Vectorization}, and {\itshape Unrolling} has the value {\itshape No\+Unrolling} (the latter is obvious since our vectors have dynamic size so there\textquotesingle{}s no way to unroll the loop at compile-\/time).

So the partial specialization of internal\+::assign\+\_\+impl that we\textquotesingle{}re looking at is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\end{DoxyCode}


Here is how it\textquotesingle{}s defined\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived1, \textcolor{keyword}{typename} Derived2>}
\DoxyCodeLine{\textcolor{keyword}{struct }internal::assign\_impl<Derived1, Derived2, LinearVectorization, NoUnrolling>}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keyword}{static} \textcolor{keywordtype}{void} run(Derived1 \&dst, \textcolor{keyword}{const} Derived2 \&src)}
\DoxyCodeLine{  \{}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} size = dst.size();}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} packetSize = internal::packet\_traits<typename Derived1::Scalar>::size;}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedStart = internal::assign\_traits<Derived1,Derived2>::DstIsAligned ? 0}
\DoxyCodeLine{                           : internal::first\_aligned(\&dst.coeffRef(0), size);}
\DoxyCodeLine{    \textcolor{keyword}{const} \textcolor{keywordtype}{int} alignedEnd = alignedStart + ((size-\/alignedStart)/packetSize)*packetSize;}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = 0; index < alignedStart; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{    \{}
\DoxyCodeLine{      dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{}
\DoxyCodeLine{    \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{      dst.copyCoeff(index, src);}
\DoxyCodeLine{  \}}
\DoxyCodeLine{\};}
\end{DoxyCode}


Here\textquotesingle{}s how it works. {\itshape Linear\+Vectorization} means that the left-\/hand and right-\/hand side expression can be accessed linearly i.\+e. you can refer to their coefficients by one integer {\itshape index}, as opposed to having to refer to its coefficients by two integers {\itshape row}, {\itshape column}.

As we said at the beginning, vectorization works with blocks of 4 floats. Here, {\itshape Packet\+Size} is 4.

There are two potential problems that we need to deal with\+: \begin{DoxyItemize}
\item first, vectorization works much better if the packets are 128-\/bit-\/aligned. This is especially important for write access. So when writing to the coefficients of {\itshape dst}, we want to group these coefficients by packets of 4 such that each of these packets is 128-\/bit-\/aligned. In general, this requires to skip a few coefficients at the beginning of {\itshape dst}. This is the purpose of {\itshape aligned\+Start}. We then copy these first few coefficients one by one, not by packets. However, in our case, the {\itshape dst} expression is a Vector\+Xf and remember that in the construction of the vectors we allocated aligned arrays. Thanks to {\itshape Dst\+Is\+Aligned}, \mbox{\hyperlink{namespace_eigen}{Eigen}} remembers that without having to do any runtime check, so {\itshape aligned\+Start} is zero and this part is avoided altogether. \item second, the number of coefficients to copy is not in general a multiple of {\itshape packet\+Size}. Here, there are 50 coefficients to copy and {\itshape packet\+Size} is 4. So we\textquotesingle{}ll have to copy the last 2 coefficients one by one, not by packets. Here, {\itshape aligned\+End} is 48.\end{DoxyItemize}
Now come the actual loops.

First, the vectorized part\+: the 48 first coefficients out of 50 will be copied by packets of 4\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}


What is copy\+Packet? It is defined in src/\+Core/\+Coeffs.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Derived>}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} OtherDerived, \textcolor{keywordtype}{int} StoreMode, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} MatrixBase<Derived>::copyPacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} MatrixBase<OtherDerived>\& other)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  eigen\_internal\_assert(index >= 0 \&\& index < size());}
\DoxyCodeLine{  derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, what are write\+Packet() and packet() here?

First, write\+Packet() here is a method on the left-\/hand side Vector\+Xf. So we go to \mbox{\hyperlink{_matrix_8h_source}{src/\+Core/\+Matrix.\+h}} to look at its definition\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keywordtype}{int} StoreMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} writePacket(\textcolor{keywordtype}{int} index, \textcolor{keyword}{const} PacketScalar\& x)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  internal::pstoret<Scalar, PacketScalar, StoreMode>(m\_storage.data() + index, x);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 Here, {\itshape Store\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8}{Aligned}}}, indicating that we are doing a 128-\/bit-\/aligned write access, {\itshape Packet\+Scalar} is a type representing a \char`\"{}\+S\+S\+E packet of 4 floats\char`\"{} and internal\+::pstoret is a function writing such a packet in memory. Their definitions are architecture-\/specific, we find them in \mbox{\hyperlink{_s_s_e_2_packet_math_8h_source}{src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h}}\+:

The line in \mbox{\hyperlink{_s_s_e_2_packet_math_8h_source}{src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h}} that determines the Packet\+Scalar type (via a typedef in \mbox{\hyperlink{_matrix_8h_source}{Matrix.\+h}}) is\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{struct }internal::packet\_traits<float>  \{ \textcolor{keyword}{typedef} \_\_m128  type; \textcolor{keyword}{enum} \{size=4\}; \};}
\end{DoxyCode}
 Here, \+\_\+\+\_\+m128 is a S\+S\+E-\/specific type. Notice that the enum {\itshape size} here is what was used to define {\itshape packet\+Size} above.

And here is the implementation of internal\+::pstoret\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstore(\textcolor{keywordtype}{float}*  to, \textcolor{keyword}{const} \_\_m128\&  from) \{ \_mm\_store\_ps(to, from); \}}
\end{DoxyCode}
 Here, \+\_\+\+\_\+mm\+\_\+store\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction. The difference between internal\+::pstore and internal\+::pstoret is that internal\+::pstoret is a dispatcher handling both the aligned and unaligned cases, you find its definition in \mbox{\hyperlink{_generic_packet_math_8h_source}{src/\+Core/\+Generic\+Packet\+Math.\+h}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar, \textcolor{keyword}{typename} Packet, \textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{\textcolor{keyword}{inline} \textcolor{keywordtype}{void} internal::pstoret(Scalar* to, \textcolor{keyword}{const} \mbox{\hyperlink{class_eigen_1_1_triplet}{Packet}}\& from)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{keywordflow}{if}(LoadMode == \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8}{Aligned}})}
\DoxyCodeLine{    internal::pstore(to, from);}
\DoxyCodeLine{  \textcolor{keywordflow}{else}}
\DoxyCodeLine{    internal::pstoreu(to, from);}
\DoxyCodeLine{\}}
\end{DoxyCode}


OK, that explains how write\+Packet() works. Now let\textquotesingle{}s look into the packet() call. Remember that we are analyzing this line of code inside copy\+Packet()\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{derived().template writePacket<StoreMode>(index,}
\DoxyCodeLine{    other.derived().template packet<LoadMode>(index));}
\end{DoxyCode}


Here, {\itshape other} is our sum expression {\itshape v} + {\itshape w}. The .derived() is just casting from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} to the subclass which here is \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}}. So let\textquotesingle{}s go to \mbox{\hyperlink{_cwise_binary_op_8h_source}{src/\+Core/\+Cwise\+Binary\+Op.\+h}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }CwiseBinaryOp}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} m\_functor.packetOp(m\_lhs.template packet<LoadMode>(index), m\_rhs.template packet<LoadMode>(index));}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 Here, {\itshape m\+\_\+lhs} is the vector {\itshape v}, and {\itshape m\+\_\+rhs} is the vector {\itshape w}. So the packet() function here is Matrix\+::packet(). The template parameter {\itshape Load\+Mode} is {\itshape \mbox{\hyperlink{group__enums_gga45fe06e29902b7a2773de05ba27b47a1ae12d0f8f869c40c76128260af2242bc8}{Aligned}}}. So we\textquotesingle{}re looking at 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{class }Matrix}
\DoxyCodeLine{\{}
\DoxyCodeLine{  \textcolor{comment}{// ...}}
\DoxyCodeLine{    \textcolor{keyword}{template}<\textcolor{keywordtype}{int} LoadMode>}
\DoxyCodeLine{    \textcolor{keyword}{inline} PacketScalar packet(\textcolor{keywordtype}{int} index)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{    }\{}
\DoxyCodeLine{      \textcolor{keywordflow}{return} internal::ploadt<Scalar, LoadMode>(m\_storage.data() + index);}
\DoxyCodeLine{    \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 We let you look up the definition of internal\+::ploadt in \mbox{\hyperlink{_generic_packet_math_8h_source}{Generic\+Packet\+Math.\+h}} and the internal\+::pload in \mbox{\hyperlink{_s_s_e_2_packet_math_8h_source}{src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h}}. It is very similar to the above for internal\+::pstore.

Let\textquotesingle{}s go back to Cwise\+Binary\+Op\+::packet(). Once the packets from the vectors {\itshape v} and {\itshape w} have been returned, what does this function do? It calls m\+\_\+functor.\+packet\+Op() on them. What is m\+\_\+functor? Here we must remember what particular template specialization of \mbox{\hyperlink{class_eigen_1_1_cwise_binary_op}{Cwise\+Binary\+Op}} we\textquotesingle{}re dealing with\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{CwiseBinaryOp<internal::scalar\_sum\_op<float>, VectorXf, VectorXf>}
\end{DoxyCode}
 So m\+\_\+functor is an object of the empty class internal\+::scalar\+\_\+sum\+\_\+op$<$float$>$. As we mentioned above, don\textquotesingle{}t worry about why we constructed an object of this empty class at all -- it\textquotesingle{}s an implementation detail, the point is that some other functors need to store member data.

Anyway, \mbox{\hyperlink{struct_eigen_1_1internal_1_1scalar__sum__op}{internal\+::scalar\+\_\+sum\+\_\+op}} is defined in src/\+Core/\+Functors.\+h\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<\textcolor{keyword}{typename} Scalar> \textcolor{keyword}{struct }internal::scalar\_sum\_op EIGEN\_EMPTY\_STRUCT \{}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} Scalar operator() (\textcolor{keyword}{const} Scalar\& a, \textcolor{keyword}{const} Scalar\& b)\textcolor{keyword}{ const }\{ \textcolor{keywordflow}{return} a + b; \}}
\DoxyCodeLine{  \textcolor{keyword}{template}<\textcolor{keyword}{typename} PacketScalar>}
\DoxyCodeLine{  \textcolor{keyword}{inline} \textcolor{keyword}{const} PacketScalar packetOp(\textcolor{keyword}{const} PacketScalar\& a, \textcolor{keyword}{const} PacketScalar\& b)\textcolor{keyword}{ const}}
\DoxyCodeLine{\textcolor{keyword}{  }\{ \textcolor{keywordflow}{return} internal::padd(a,b); \}}
\DoxyCodeLine{\};}
\end{DoxyCode}
 As you can see, all what packet\+Op() does is to call internal\+::padd on the two packets. Here is the definition of internal\+::padd from \mbox{\hyperlink{_s_s_e_2_packet_math_8h_source}{src/\+Core/arch/\+S\+S\+E/\+Packet\+Math.\+h}}\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keyword}{template}<> \textcolor{keyword}{inline} \_\_m128  internal::padd(\textcolor{keyword}{const} \_\_m128\&  a, \textcolor{keyword}{const} \_\_m128\&  b) \{ \textcolor{keywordflow}{return} \_mm\_add\_ps(a,b); \}}
\end{DoxyCode}
 Here, \+\_\+mm\+\_\+add\+\_\+ps is a S\+S\+E-\/specific intrinsic function, representing a single S\+SE instruction.

To summarize, the loop 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedStart; index < alignedEnd; index += packetSize)}
\DoxyCodeLine{\{}
\DoxyCodeLine{  dst.template copyPacket<Derived2, Aligned, internal::assign\_traits<Derived1,Derived2>::SrcAlignment>(index, src);}
\DoxyCodeLine{\}}
\end{DoxyCode}
 has been compiled to the following code\+: for {\itshape index} going from 0 to the 11 ( = 48/4 -\/ 1), read the i-\/th packet (of 4 floats) from the vector v and the i-\/th packet from the vector w using two \+\_\+\+\_\+mm\+\_\+load\+\_\+ps S\+SE instructions, then add them together using a \+\_\+\+\_\+mm\+\_\+add\+\_\+ps instruction, then store the result using a \+\_\+\+\_\+mm\+\_\+store\+\_\+ps instruction.

There remains the second loop handling the last few (here, the last 2) coefficients\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} index = alignedEnd; index < size; index++)}
\DoxyCodeLine{  dst.copyCoeff(index, src);}
\end{DoxyCode}
 However, it works just like the one we just explained, it is just simpler because there is no S\+SE vectorization involved here. copy\+Packet() becomes copy\+Coeff(), packet() becomes coeff(), write\+Packet() becomes coeff\+Ref(). If you followed us this far, you can probably understand this part by yourself.

We see that all the C++ abstraction of \mbox{\hyperlink{namespace_eigen}{Eigen}} goes away during compilation and that we indeed are precisely controlling which assembly instructions we emit. Such is the beauty of C++! Since we have such precise control over the emitted assembly instructions, but such complex logic to choose the right instructions, we can say that \mbox{\hyperlink{namespace_eigen}{Eigen}} really behaves like an optimizing compiler. If you prefer, you could say that \mbox{\hyperlink{namespace_eigen}{Eigen}} behaves like a script for the compiler. In a sense, C++ template metaprogramming is scripting the compiler -- and it\textquotesingle{}s been shown that this scripting language is Turing-\/complete. See \href{http://en.wikipedia.org/wiki/Template_metaprogramming}{\texttt{ Wikipedia}}. \hypertarget{TopicClassHierarchy}{}\doxysubsection{The class hierarchy}\label{TopicClassHierarchy}
This page explains the design of the core classes in \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy and how they fit together. Casual users probably need not concern themselves with these details, but it may be useful for both advanced users and \mbox{\hyperlink{namespace_eigen}{Eigen}} developers.

\textbackslash{}eigen\+Auto\+Toc\hypertarget{_topic_class_hierarchy_TopicClassHierarchyPrinciples}{}\doxysubsubsection{Principles}\label{_topic_class_hierarchy_TopicClassHierarchyPrinciples}
\mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s class hierarchy is designed so that virtual functions are avoided where their overhead would significantly impair performance. Instead, \mbox{\hyperlink{namespace_eigen}{Eigen}} achieves polymorphism with the Curiously Recurring Template Pattern (C\+R\+TP). In this pattern, the base class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}}) is in fact a template class, and the derived class (for instance, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}}) inherits the base class with the derived class itself as a template argument (in this case, {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}} inherits from {\ttfamily \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$\mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}$>$}). This allows \mbox{\hyperlink{namespace_eigen}{Eigen}} to resolve the polymorphic function calls at compile time.

In addition, the design avoids multiple inheritance. One reason for this is that in our experience, some compilers (like M\+S\+VC) fail to perform empty base class optimization, which is crucial for our fixed-\/size types.\hypertarget{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}{}\doxysubsubsection{The core classes}\label{_topic_class_hierarchy_TopicClassHierarchyCoreClasses}
These are the classes that you need to know about if you want to write functions that accept or return \mbox{\hyperlink{namespace_eigen}{Eigen}} objects.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} means plain dense matrix. If {\ttfamily m} is a {\ttfamily Matrix}, then, for instance, {\ttfamily m+m} is no longer a {\ttfamily Matrix}, it is a \char`\"{}matrix expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} means dense matrix expression. This means that a {\ttfamily Matrix\+Base} is something that can be added, matrix-\/multiplied, L\+U-\/decomposed, Q\+R-\/decomposed... All matrix expression classes, including {\ttfamily Matrix} itself, inherit {\ttfamily Matrix\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_array}{Array}} means plain dense array. If {\ttfamily x} is an {\ttfamily Array}, then, for instance, {\ttfamily x+x} is no longer an {\ttfamily Array}, it is an \char`\"{}array expression\char`\"{}.
\item \mbox{\hyperlink{class_eigen_1_1_array_base}{Array\+Base}} means dense array expression. This means that an {\ttfamily Array\+Base} is something that can be added, array-\/multiplied, and on which you can perform all sorts of array operations... All array expression classes, including {\ttfamily Array} itself, inherit {\ttfamily Array\+Base}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_base}{Dense\+Base}} means dense (matrix or array) expression. Both {\ttfamily Array\+Base} and {\ttfamily Matrix\+Base} inherit {\ttfamily Dense\+Base}. {\ttfamily Dense\+Base} is where all the methods go that apply to dense expressions regardless of whether they are matrix or array expressions. For example, the \mbox{\hyperlink{}{block(...) }} methods are in {\ttfamily Dense\+Base}.
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}{}\doxysubsubsection{Base classes}\label{_topic_class_hierarchy_TopicClassHierarchyBaseClasses}
These classes serve as base classes for the five core classes mentioned above. They are more internal and so less interesting for users of the \mbox{\hyperlink{namespace_eigen}{Eigen}} library.


\begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{Plain\+Object\+Base}} means dense (matrix or array) plain object, i.\+e. something that stores its own dense array of coefficients. This is where, for instance, the \mbox{\hyperlink{class_eigen_1_1_plain_object_base_a99d9054ee2d5a40c6e00ded0265e9cea}{resize() }} methods go. {\ttfamily Plain\+Object\+Base} is inherited by {\ttfamily Matrix} and by {\ttfamily Array}. But above, we said that {\ttfamily Matrix} inherits {\ttfamily Matrix\+Base} and {\ttfamily Array} inherits {\ttfamily Array\+Base}. So does that mean multiple inheritance? No, because {\ttfamily Plain\+Object\+Base} {\itshape itself} inherits {\ttfamily Matrix\+Base} or {\ttfamily Array\+Base} depending on whether we are in the matrix or array case. When we said above that {\ttfamily Matrix} inherited {\ttfamily Matrix\+Base}, we omitted to say it does so indirectly via {\ttfamily Plain\+Object\+Base}. Same for {\ttfamily Array}.
\item \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{Dense\+Coeffs\+Base}} means something that has dense coefficient accessors. It is a base class for {\ttfamily Dense\+Base}. The reason for {\ttfamily Dense\+Coeffs\+Base} to exist is that the set of available coefficient accessors is very different depending on whether a dense expression has direct memory access or not (the {\ttfamily Direct\+Access\+Bit} flag). For example, if {\ttfamily x} is a plain matrix, then {\ttfamily x} has direct access, and {\ttfamily x.\+transpose()} and {\ttfamily x.\+block(...)} also have direct access, because their coefficients can be read right off memory, but for example, {\ttfamily x+x} does not have direct memory access, because obtaining any of its coefficients requires a computation (an addition), it can\textquotesingle{}t be just read off memory.
\item \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}} means anything that can be evaluated into a plain dense matrix or array (even if that would be a bad idea). {\ttfamily Eigen\+Base} is really the absolute base class for anything that remotely looks like a matrix or array. It is a base class for {\ttfamily Dense\+Coeffs\+Base}, so it sits below all our dense class hierarchy, but it is not limited to dense expressions. For example, {\ttfamily Eigen\+Base} is also inherited by diagonal matrices, sparse matrices, etc...
\end{DoxyItemize}\hypertarget{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}{}\doxysubsubsection{Inheritance diagrams}\label{_topic_class_hierarchy_TopicClassHierarchyInheritanceDiagrams}
The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Matrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Matrix>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Matrix>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<Matrix>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Matrix>    (matrix case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}}
\end{DoxyPre}


The inheritance diagram for \mbox{\hyperlink{class_eigen_1_1_array}{Array}} looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<Array>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<Array>    (direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<Array>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<Array>
        <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_plain_object_base}{PlainObjectBase}}<Array>    (array case)
          <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array}{Array}}
\end{DoxyPre}


The inheritance diagram for some other matrix expression class, here denoted by {\ttfamily Some\+Matrix\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeMatrixXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeMatrixXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeMatrixXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_matrix_base}{MatrixBase}}<SomeMatrixXpr>
        <-\/-\/ SomeMatrixXpr
\end{DoxyPre}


The inheritance diagram for some other array expression class, here denoted by {\ttfamily Some\+Array\+Xpr}, looks as follows\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<SomeArrayXpr>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_coeffs_base}{DenseCoeffsBase}}<SomeArrayXpr>    (direct access or no direct access case)
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_dense_base}{DenseBase}}<SomeArrayXpr>
      <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_array_base}{ArrayBase}}<SomeArrayXpr>
        <-\/-\/ SomeArrayXpr
\end{DoxyPre}


Finally, consider an example of something that is not a dense expression, for instance a diagonal matrix. The corresponding inheritance diagram is\+:


\begin{DoxyPre}
\mbox{\hyperlink{struct_eigen_1_1_eigen_base}{EigenBase}}<DiagonalMatrix>
  <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_base}{DiagonalBase}}<DiagonalMatrix>
    <-\/-\/ \mbox{\hyperlink{class_eigen_1_1_diagonal_matrix}{DiagonalMatrix}}
\end{DoxyPre}
 \hypertarget{TopicLazyEvaluation}{}\doxysubsection{Lazy Evaluation and Aliasing}\label{TopicLazyEvaluation}
Executive summary\+: \mbox{\hyperlink{namespace_eigen}{Eigen}} has intelligent compile-\/time mechanisms to enable lazy evaluation and removing temporaries where appropriate. It will handle aliasing automatically in most cases, for example with matrix products. The automatic behavior can be overridden manually by using the \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{Matrix\+Base\+::eval()}} and \mbox{\hyperlink{class_eigen_1_1_matrix_base_a2c1085de7645f23f240876388457da0b}{Matrix\+Base\+::noalias()}} methods.

When you write a line of code involving a complex expression such as


\begin{DoxyCode}{0}
\DoxyCodeLine{mat1 = mat2 + mat3 * (mat4 + mat5); }
\end{DoxyCode}


\mbox{\hyperlink{namespace_eigen}{Eigen}} determines automatically, for each sub-\/expression, whether to evaluate it into a temporary variable. Indeed, in certain cases it is better to evaluate immediately a sub-\/expression into a temporary variable, while in other cases it is better to avoid that.

A traditional math library without expression templates always evaluates all sub-\/expressions into temporaries. So with this code,


\begin{DoxyCode}{0}
\DoxyCodeLine{vec1 = vec2 + vec3; }
\end{DoxyCode}


a traditional library would evaluate {\ttfamily vec2} + vec3 into a temporary {\ttfamily vec4} and then copy {\ttfamily vec4} into {\ttfamily vec1}. This is of course inefficient\+: the arrays are traversed twice, so there are a lot of useless load/store operations.

Expression-\/templates-\/based libraries can avoid evaluating sub-\/expressions into temporaries, which in many cases results in large speed improvements. This is called {\itshape lazy evaluation} as an expression is getting evaluated as late as possible, instead of immediately. However, most other expression-\/templates-\/based libraries {\itshape always} choose lazy evaluation. There are two problems with that\+: first, lazy evaluation is not always a good choice for performance; second, lazy evaluation can be very dangerous, for example with matrix products\+: doing {\ttfamily matrix = matrix$\ast$matrix} gives a wrong result if the matrix product is lazy-\/evaluated, because of the way matrix product works.

For these reasons, \mbox{\hyperlink{namespace_eigen}{Eigen}} has intelligent compile-\/time mechanisms to determine automatically when to use lazy evaluation, and when on the contrary it should evaluate immediately into a temporary variable.

So in the basic example,


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1 = matrix2 + matrix3; }
\end{DoxyCode}


\mbox{\hyperlink{namespace_eigen}{Eigen}} chooses lazy evaluation. Thus the arrays are traversed only once, producing optimized code. If you really want to force immediate evaluation, use \mbox{\hyperlink{class_eigen_1_1_dense_base_a5df64c66228ba75bbc66db2584185527}{eval()}}\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1 = (matrix2 + matrix3).eval(); }
\end{DoxyCode}


Here is now a more involved example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1 = -\/matrix2 + matrix3 + 5 * matrix4; }
\end{DoxyCode}


\mbox{\hyperlink{namespace_eigen}{Eigen}} chooses lazy evaluation at every stage in that example, which is clearly the correct choice. In fact, lazy evaluation is the \char`\"{}default choice\char`\"{} and \mbox{\hyperlink{namespace_eigen}{Eigen}} will choose it except in a few circumstances.

{\bfseries{The first circumstance}} in which \mbox{\hyperlink{namespace_eigen}{Eigen}} chooses immediate evaluation, is when it sees an assignment {\ttfamily a = b;} and the expression {\ttfamily b} has the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}. The most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix = matrix * matrix; }
\end{DoxyCode}


\mbox{\hyperlink{namespace_eigen}{Eigen}} first evaluates {\ttfamily matrix $\ast$ matrix} into a temporary matrix, and then copies it into the original {\ttfamily matrix}. This guarantees a correct result as we saw above that lazy evaluation gives wrong results with matrix products. It also doesn\textquotesingle{}t cost much, as the cost of the matrix product itself is much higher.

What if you know that the result does no alias the operand of the product and want to force lazy evaluation? Then use \mbox{\hyperlink{class_eigen_1_1_matrix_base_a2c1085de7645f23f240876388457da0b}{.noalias()}} instead. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1.noalias() = matrix2 * matrix2; }
\end{DoxyCode}


Here, since we know that matrix2 is not the same matrix as matrix1, we know that lazy evaluation is not dangerous, so we may force lazy evaluation. Concretely, the effect of noalias() here is to bypass the evaluate-\/before-\/assigning \mbox{\hyperlink{group__flags}{flag}}.

{\bfseries{The second circumstance}} in which \mbox{\hyperlink{namespace_eigen}{Eigen}} chooses immediate evaluation, is when it sees a nested expression such as {\ttfamily a + b} where {\ttfamily b} is already an expression having the evaluate-\/before-\/nesting \mbox{\hyperlink{group__flags}{flag}}. Again, the most important example of such an expression is the \mbox{\hyperlink{class_eigen_1_1_product}{matrix product expression}}. For example, when you do


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1 = matrix2 + matrix3 * matrix4; }
\end{DoxyCode}


the product {\ttfamily matrix3 $\ast$ matrix4} gets evaluated immediately into a temporary matrix. Indeed, experiments showed that it is often beneficial for performance to evaluate immediately matrix products when they are nested into bigger expressions.

{\bfseries{The third circumstance}} in which \mbox{\hyperlink{namespace_eigen}{Eigen}} chooses immediate evaluation, is when its cost model shows that the total cost of an operation is reduced if a sub-\/expression gets evaluated into a temporary. Indeed, in certain cases, an intermediate result is sufficiently costly to compute and is reused sufficiently many times, that is worth \char`\"{}caching\char`\"{}. Here is an example\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{matrix1 = matrix2 * (matrix3 + matrix4); }
\end{DoxyCode}


Here, provided the matrices have at least 2 rows and 2 columns, each coefficienct of the expression {\ttfamily matrix3 + matrix4} is going to be used several times in the matrix product. Instead of computing the sum everytime, it is much better to compute it once and store it in a temporary variable. \mbox{\hyperlink{namespace_eigen}{Eigen}} understands this and evaluates {\ttfamily matrix3 + matrix4} into a temporary variable before evaluating the product. \hypertarget{TopicCMakeGuide}{}\doxysection{Using Eigen in C\+Make Projects}\label{TopicCMakeGuide}
Eigen provides native C\+Make support which allows the library to be easily used in C\+Make projects.

\begin{DoxyNote}{Note}
C\+Make 3.\+0 (or later) is required to enable this functionality.
\end{DoxyNote}
Eigen exports a C\+Make target called {\ttfamily Eigen3\+::\+Eigen} which can be imported using the {\ttfamily find\+\_\+package} C\+Make command and used by calling {\ttfamily target\+\_\+link\+\_\+libraries} as in the following example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake\_minimum\_required (VERSION 3.0)}
\DoxyCodeLine{project (myproject)}
\DoxyCodeLine{}
\DoxyCodeLine{find\_package (Eigen3 3.3 REQUIRED NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{add\_executable (example example.cpp)}
\DoxyCodeLine{target\_link\_libraries (example Eigen3::Eigen)}
\end{DoxyCode}


The above code snippet must be placed in a file called {\ttfamily C\+Make\+Lists.\+txt} alongside {\ttfamily example.\+cpp}. After running 
\begin{DoxyCode}{0}
\DoxyCodeLine{\$ cmake path-\/to-\/example-\/directory}
\end{DoxyCode}
 C\+Make will produce project files that generate an executable called {\ttfamily example} which requires at least version 3.\+3 of Eigen. Here, {\ttfamily path-\/to-\/example-\/directory} is the path to the directory that contains both {\ttfamily C\+Make\+Lists.\+txt} and {\ttfamily example.\+cpp}.

If you have multiple installed version of Eigen, you can pick your favorite one by setting the {\ttfamily Eigen3\+\_\+\+D\+IR} cmake\textquotesingle{}s variable to the respective path containing the {\ttfamily Eigen3$\ast$}.cmake files. For instance\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{cmake path-\/to-\/example-\/directory -\/DEigen3\_DIR=\$HOME/mypackages/share/eigen3/cmake/}
\end{DoxyCode}


If the {\ttfamily R\+E\+Q\+U\+I\+R\+ED} option is omitted when locating Eigen using {\ttfamily find\+\_\+package}, one can check whether the package was found as follows\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{find\_package (Eigen3 3.3 NO\_MODULE)}
\DoxyCodeLine{}
\DoxyCodeLine{if (TARGET Eigen3::Eigen)}
\DoxyCodeLine{  \# Use the imported target}
\DoxyCodeLine{endif (TARGET Eigen3::Eigen)}
\end{DoxyCode}
 