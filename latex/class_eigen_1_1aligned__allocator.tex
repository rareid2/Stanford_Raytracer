\hypertarget{class_eigen_1_1aligned__allocator}{}\doxysection{Eigen\+::aligned\+\_\+allocator$<$ T $>$ Class Template Reference}
\label{class_eigen_1_1aligned__allocator}\index{Eigen::aligned\_allocator$<$ T $>$@{Eigen::aligned\_allocator$<$ T $>$}}


S\+TL compatible allocator to use with types requiring a non standrad alignment.  




{\ttfamily \#include $<$Memory.\+h$>$}

Inheritance diagram for Eigen\+::aligned\+\_\+allocator$<$ T $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{class_eigen_1_1aligned__allocator}
\end{center}
\end{figure}
\doxysubsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \mbox{\hyperlink{struct_eigen_1_1aligned__allocator_1_1rebind}{rebind}}
\end{DoxyCompactItemize}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a2250815f042d86cb48c8e8fb960db280}\label{class_eigen_1_1aligned__allocator_a2250815f042d86cb48c8e8fb960db280}} 
typedef std\+::size\+\_\+t {\bfseries size\+\_\+type}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a390bc09fb087d94423c42cf3428f0a24}\label{class_eigen_1_1aligned__allocator_a390bc09fb087d94423c42cf3428f0a24}} 
typedef std\+::ptrdiff\+\_\+t {\bfseries difference\+\_\+type}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a0973991f7b26d4113d52aa57284e0360}\label{class_eigen_1_1aligned__allocator_a0973991f7b26d4113d52aa57284e0360}} 
typedef \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries pointer}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a0c3b4937cc7a495af864800176e3b9ca}\label{class_eigen_1_1aligned__allocator_a0c3b4937cc7a495af864800176e3b9ca}} 
typedef \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries reference}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a2188bac5dd2a2208a02c9dc934acb451}\label{class_eigen_1_1aligned__allocator_a2188bac5dd2a2208a02c9dc934acb451}} 
typedef \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} {\bfseries value\+\_\+type}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a7076a7a6ccb57759a910860135253543}\label{class_eigen_1_1aligned__allocator_a7076a7a6ccb57759a910860135253543}} 
{\bfseries aligned\+\_\+allocator} (const \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\+\_\+allocator}} \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a19b1a156baf134359d088dc9127fc2c1}\label{class_eigen_1_1aligned__allocator_a19b1a156baf134359d088dc9127fc2c1}} 
{\footnotesize template$<$class U $>$ }\\{\bfseries aligned\+\_\+allocator} (const \mbox{\hyperlink{class_eigen_1_1aligned__allocator}{aligned\+\_\+allocator}}$<$ U $>$ \&other)
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a11f921b8c551f8f89c5b6252a2cbfac0}\label{class_eigen_1_1aligned__allocator_a11f921b8c551f8f89c5b6252a2cbfac0}} 
\mbox{\hyperlink{class_eigen_1_1_triplet}{pointer}} {\bfseries allocate} (size\+\_\+type num, const void $\ast$=0)
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_ae00326806b7ba19c141c6c61a5f7b1ad}\label{class_eigen_1_1aligned__allocator_ae00326806b7ba19c141c6c61a5f7b1ad}} 
void {\bfseries deallocate} (\mbox{\hyperlink{class_eigen_1_1_triplet}{pointer}} p, size\+\_\+type)
\end{DoxyCompactItemize}
\doxysubsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_a5de6959ae3ee9675f8182591a823d264}\label{class_eigen_1_1aligned__allocator_a5de6959ae3ee9675f8182591a823d264}} 
const typedef \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $\ast$ {\bfseries const\+\_\+pointer}
\item 
\mbox{\Hypertarget{class_eigen_1_1aligned__allocator_ab6c1e86436291bd117dedb20fba39b4c}\label{class_eigen_1_1aligned__allocator_ab6c1e86436291bd117dedb20fba39b4c}} 
const typedef \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} \& {\bfseries const\+\_\+reference}
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$class T$>$\newline
class Eigen\+::aligned\+\_\+allocator$<$ T $>$}

S\+TL compatible allocator to use with types requiring a non standrad alignment. 

The memory is aligned as for dynamically aligned matrix/array types such as Matrix\+Xd. By default, it will thus provide at least 16 bytes alignment and more in following cases\+:
\begin{DoxyItemize}
\item 32 bytes alignment if A\+VX is enabled.
\item 64 bytes alignment if A\+V\+X512 is enabled.
\end{DoxyItemize}

This can be controled using the {\ttfamily E\+I\+G\+E\+N\+\_\+\+M\+A\+X\+\_\+\+A\+L\+I\+G\+N\+\_\+\+B\+Y\+T\+ES} macro as documented \mbox{\hyperlink{_topic_preprocessor_directives_TopicPreprocessorDirectivesPerformance}{there }}.

Example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{comment}{// Matrix4f requires 16 bytes alignment:}}
\DoxyCodeLine{std::map< int, Matrix4f, std::less<int>, }
\DoxyCodeLine{          aligned\_allocator<std::pair<const int, Matrix4f> > > my\_map\_mat4;}
\DoxyCodeLine{\textcolor{comment}{// Vector3f does not require 16 bytes alignment, no need to use Eigen's allocator:}}
\DoxyCodeLine{std::map< int, Vector3f > my\_map\_vec3;}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\textbackslash{}blank \mbox{\hyperlink{group___topic_stl_containers}{Topic\+Stl\+Containers}}. 
\end{DoxySeeAlso}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/rileyannereid/\+Pycharm\+Projects/\+Stanford\+\_\+\+Raytracer/damping/lib/eigen/\+Eigen/src/\+Core/util/Memory.\+h\end{DoxyCompactItemize}
