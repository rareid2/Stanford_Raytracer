\hypertarget{class_eigen_1_1_least_squares_conjugate_gradient}{}\doxysection{Eigen\+::Least\+Squares\+Conjugate\+Gradient$<$ \+\_\+\+Matrix\+Type, \+\_\+\+Preconditioner $>$ Class Template Reference}
\label{class_eigen_1_1_least_squares_conjugate_gradient}\index{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$@{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$}}


A conjugate gradient solver for sparse (or dense) least-\/square problems.  




{\ttfamily \#include $<$Least\+Square\+Conjugate\+Gradient.\+h$>$}

\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a56c5362953670bfd8cfa31a51d18ee47}\label{class_eigen_1_1_least_squares_conjugate_gradient_a56c5362953670bfd8cfa31a51d18ee47}} 
typedef \+\_\+\+Matrix\+Type {\bfseries Matrix\+Type}
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a9b8be7215e7a9d0871517ccee24d9857}\label{class_eigen_1_1_least_squares_conjugate_gradient_a9b8be7215e7a9d0871517ccee24d9857}} 
typedef Matrix\+Type\+::\+Scalar {\bfseries Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a81b0c2843b7d4118c8cf0529bc21924d}\label{class_eigen_1_1_least_squares_conjugate_gradient_a81b0c2843b7d4118c8cf0529bc21924d}} 
typedef Matrix\+Type\+::\+Real\+Scalar {\bfseries Real\+Scalar}
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_addeb2525fd746662bee305d73f360204}\label{class_eigen_1_1_least_squares_conjugate_gradient_addeb2525fd746662bee305d73f360204}} 
typedef \+\_\+\+Preconditioner {\bfseries Preconditioner}
\end{DoxyCompactItemize}
\doxysubsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient_ace69f423fcc1f8960d0e2de0667447c9}{Least\+Squares\+Conjugate\+Gradient}} ()
\item 
{\footnotesize template$<$typename Matrix\+Derived $>$ }\\\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient_a91c4f2edc20f93cee9b721165937fb99}{Least\+Squares\+Conjugate\+Gradient}} (const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&\mbox{\hyperlink{class_eigen_1_1_matrix}{A}})
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a04c0c32b322d74949d190731a354340e}\label{class_eigen_1_1_least_squares_conjugate_gradient_a04c0c32b322d74949d190731a354340e}} 
{\footnotesize template$<$typename Rhs , typename Dest $>$ }\\void {\bfseries \+\_\+solve\+\_\+with\+\_\+guess\+\_\+impl} (const Rhs \&b, Dest \&x) const
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_aaadb8f72ca585e7dd5f41ddf7e14a9d3}\label{class_eigen_1_1_least_squares_conjugate_gradient_aaadb8f72ca585e7dd5f41ddf7e14a9d3}} 
{\footnotesize template$<$typename Rhs , typename Dest $>$ }\\void {\bfseries \+\_\+solve\+\_\+impl} (const \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}$<$ Rhs $>$ \&b, Dest \&x) const
\item 
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a7c2a35dde0ddb891b4030143ed286743}\label{class_eigen_1_1_least_squares_conjugate_gradient_a7c2a35dde0ddb891b4030143ed286743}} 
{\footnotesize template$<$typename Rhs , typename Dest\+Derived $>$ }\\void {\bfseries \+\_\+solve\+\_\+impl} (const Rhs \&b, \mbox{\hyperlink{class_eigen_1_1_sparse_matrix_base}{Sparse\+Matrix\+Base}}$<$ Dest\+Derived $>$ \&a\+Dest) const
\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
\subsubsection*{template$<$typename \+\_\+\+Matrix\+Type, typename \+\_\+\+Preconditioner$>$\newline
class Eigen\+::\+Least\+Squares\+Conjugate\+Gradient$<$ \+\_\+\+Matrix\+Type, \+\_\+\+Preconditioner $>$}

A conjugate gradient solver for sparse (or dense) least-\/square problems. 

This class allows to solve for A x = b linear problems using an iterative conjugate gradient algorithm. The matrix A can be non symmetric and rectangular, but the matrix A\textquotesingle{} A should be positive-\/definite to guaranty stability. Otherwise, the \mbox{\hyperlink{class_eigen_1_1_sparse_l_u}{Sparse\+LU}} or \mbox{\hyperlink{class_eigen_1_1_sparse_q_r}{Sparse\+QR}} classes might be preferable. The matrix A and the vectors x and b can be either dense or sparse.


\begin{DoxyTemplParams}{Template Parameters}
{\em \+\_\+\+Matrix\+Type} & the type of the matrix A, can be a dense or a sparse matrix. \\
\hline
{\em \+\_\+\+Preconditioner} & the type of the preconditioner. Default is \mbox{\hyperlink{class_eigen_1_1_least_square_diagonal_preconditioner}{Least\+Square\+Diagonal\+Preconditioner}}\\
\hline
\end{DoxyTemplParams}
\textbackslash{}implsparsesolverconcept

The maximal number of iterations and tolerance value can be controlled via the set\+Max\+Iterations() and set\+Tolerance() methods. The defaults are the size of the problem for the maximal number of iterations and Num\+Traits$<$\+Scalar$>$\+::epsilon() for the tolerance.

This class can be used as the direct solver classes. Here is a typical usage example\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{\textcolor{keywordtype}{int} m=1000000, n = 10000;}
\DoxyCodeLine{VectorXd x(n), b(m);}
\DoxyCodeLine{SparseMatrix<double> A(m,n);}
\DoxyCodeLine{\textcolor{comment}{// fill A and b}}
\DoxyCodeLine{LeastSquaresConjugateGradient<SparseMatrix<double> > lscg;}
\DoxyCodeLine{lscg.compute(A);}
\DoxyCodeLine{x = lscg.solve(b);}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"\#iterations:     "} << lscg.iterations() << std::endl;}
\DoxyCodeLine{std::cout << \textcolor{stringliteral}{"estimated error: "} << lscg.error()      << std::endl;}
\DoxyCodeLine{\textcolor{comment}{// update b, and solve again}}
\DoxyCodeLine{x = lscg.solve(b);}
\end{DoxyCode}


By default the iterations start with x=0 as an initial guess of the solution. One can control the start using the solve\+With\+Guess() method.

\begin{DoxySeeAlso}{See also}
class \mbox{\hyperlink{class_eigen_1_1_conjugate_gradient}{Conjugate\+Gradient}}, \mbox{\hyperlink{class_eigen_1_1_sparse_l_u}{Sparse\+LU}}, \mbox{\hyperlink{class_eigen_1_1_sparse_q_r}{Sparse\+QR}} 
\end{DoxySeeAlso}


\doxysubsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_ace69f423fcc1f8960d0e2de0667447c9}\label{class_eigen_1_1_least_squares_conjugate_gradient_ace69f423fcc1f8960d0e2de0667447c9}} 
\index{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$@{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$}!LeastSquaresConjugateGradient@{LeastSquaresConjugateGradient}}
\index{LeastSquaresConjugateGradient@{LeastSquaresConjugateGradient}!Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$@{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$}}
\doxysubsubsection{\texorpdfstring{LeastSquaresConjugateGradient()}{LeastSquaresConjugateGradient()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Matrix\+Type , typename \+\_\+\+Preconditioner $>$ \\
\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Eigen\+::\+Least\+Squares\+Conjugate\+Gradient}}$<$ \+\_\+\+Matrix\+Type, \+\_\+\+Preconditioner $>$\+::\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Least\+Squares\+Conjugate\+Gradient}} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Default constructor. \mbox{\Hypertarget{class_eigen_1_1_least_squares_conjugate_gradient_a91c4f2edc20f93cee9b721165937fb99}\label{class_eigen_1_1_least_squares_conjugate_gradient_a91c4f2edc20f93cee9b721165937fb99}} 
\index{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$@{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$}!LeastSquaresConjugateGradient@{LeastSquaresConjugateGradient}}
\index{LeastSquaresConjugateGradient@{LeastSquaresConjugateGradient}!Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$@{Eigen::LeastSquaresConjugateGradient$<$ \_MatrixType, \_Preconditioner $>$}}
\doxysubsubsection{\texorpdfstring{LeastSquaresConjugateGradient()}{LeastSquaresConjugateGradient()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily template$<$typename \+\_\+\+Matrix\+Type , typename \+\_\+\+Preconditioner $>$ \\
template$<$typename Matrix\+Derived $>$ \\
\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Eigen\+::\+Least\+Squares\+Conjugate\+Gradient}}$<$ \+\_\+\+Matrix\+Type, \+\_\+\+Preconditioner $>$\+::\mbox{\hyperlink{class_eigen_1_1_least_squares_conjugate_gradient}{Least\+Squares\+Conjugate\+Gradient}} (\begin{DoxyParamCaption}\item[{const \mbox{\hyperlink{struct_eigen_1_1_eigen_base}{Eigen\+Base}}$<$ Matrix\+Derived $>$ \&}]{A }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}

Initialize the solver with matrix {\itshape A} for further {\ttfamily Ax=b} solving.

This constructor is a shortcut for the default constructor followed by a call to compute().

\begin{DoxyWarning}{Warning}
this class stores a reference to the matrix A as well as some precomputed values that depend on it. Therefore, if {\itshape A} is changed this class becomes invalid. Call compute() to update it with the new matrix A, or modify a copy of A. 
\end{DoxyWarning}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/rileyannereid/\+Pycharm\+Projects/\+Stanford\+\_\+\+Raytracer/damping/lib/eigen/\+Eigen/src/\+Iterative\+Linear\+Solvers/Least\+Square\+Conjugate\+Gradient.\+h\end{DoxyCompactItemize}
