
\begin{DoxyItemize}
\item \mbox{\hyperlink{TopicResizing}{Resizing}}
\item \mbox{\hyperlink{TopicVectorization}{Vectorization}}
\item \mbox{\hyperlink{TopicEigenExpressionTemplates}{Expression templates in Eigen}}
\item \mbox{\hyperlink{TopicScalarTypes}{Scalar types}}
\item \mbox{\hyperlink{GettingStarted}{Getting started}}
\item \mbox{\hyperlink{_tutorial_sparse_example_details}{Tutorial\+Sparse\+\_\+example\+\_\+details}}
\item \mbox{\hyperlink{TopicWritingEfficientProductExpression}{Writing efficient matrix product expressions}}
\item \mbox{\hyperlink{Experimental}{Experimental parts of Eigen}} 
\end{DoxyItemize}\hypertarget{TopicResizing}{}\doxysection{Resizing}\label{TopicResizing}
T\+O\+DO\+: write this dox page!

Is linked from the tutorial on the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. \hypertarget{TopicVectorization}{}\doxysection{Vectorization}\label{TopicVectorization}
T\+O\+DO\+: write this dox page! \hypertarget{TopicEigenExpressionTemplates}{}\doxysection{Expression templates in Eigen}\label{TopicEigenExpressionTemplates}
T\+O\+DO\+: write this dox page!

Is linked from the tutorial on arithmetic ops. \hypertarget{TopicScalarTypes}{}\doxysection{Scalar types}\label{TopicScalarTypes}
T\+O\+DO\+: write this dox page!

Is linked from the tutorial on the \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} class. \hypertarget{GettingStarted}{}\doxysection{Getting started}\label{GettingStarted}
\textbackslash{}eigen\+Auto\+Toc

This is a very short guide on how to get started with \mbox{\hyperlink{namespace_eigen}{Eigen}}. It has a dual purpose. It serves as a minimal introduction to the \mbox{\hyperlink{namespace_eigen}{Eigen}} library for people who want to start coding as soon as possible. You can also read this page as the first part of the Tutorial, which explains the library in more detail; in this case you will continue with \mbox{\hyperlink{group___tutorial_matrix_class}{Tutorial\+Matrix\+Class}}.\hypertarget{_getting_started_GettingStartedInstallation}{}\doxysubsection{How to \char`\"{}install\char`\"{} Eigen?}\label{_getting_started_GettingStartedInstallation}
In order to use \mbox{\hyperlink{namespace_eigen}{Eigen}}, you just need to download and extract \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s source code (see \href{http://eigen.tuxfamily.org/index.php?title=Main_Page\#Download}{\texttt{ the wiki}} for download instructions). In fact, the header files in the {\ttfamily \mbox{\hyperlink{namespace_eigen}{Eigen}}} subdirectory are the only files required to compile programs using \mbox{\hyperlink{namespace_eigen}{Eigen}}. The header files are the same for all platforms. It is not necessary to use C\+Make or install anything.\hypertarget{_getting_started_GettingStartedFirstProgram}{}\doxysubsection{A simple first program}\label{_getting_started_GettingStartedFirstProgram}
Here is a rather simple program to get you started.


\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}


We will explain the program after telling you how to compile it.\hypertarget{_getting_started_GettingStartedCompiling}{}\doxysubsection{Compiling and running your first program}\label{_getting_started_GettingStartedCompiling}
There is no library to link to. The only thing that you need to keep in mind when compiling the above program is that the compiler must be able to find the \mbox{\hyperlink{namespace_eigen}{Eigen}} header files. The directory in which you placed \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s source code must be in the include path. With G\+CC you use the -\/I option to achieve this, so you can compile the program with a command like this\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{g++ -\/I /path/to/eigen/ my\_program.cpp -\/o my\_program }
\end{DoxyCode}


On Linux or Mac OS X, another option is to symlink or copy the \mbox{\hyperlink{namespace_eigen}{Eigen}} folder into /usr/local/include/. This way, you can compile the program with\+:


\begin{DoxyCode}{0}
\DoxyCodeLine{g++ my\_program.cpp -\/o my\_program }
\end{DoxyCode}


When you run the program, it produces the following output\+:


\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
\hypertarget{_getting_started_GettingStartedExplanation}{}\doxysubsection{Explanation of the first program}\label{_getting_started_GettingStartedExplanation}
The \mbox{\hyperlink{namespace_eigen}{Eigen}} header files define many types, but for simple applications it may be enough to use only the {\ttfamily Matrix\+Xd} type. This represents a matrix of arbitrary size (hence the {\ttfamily X} in {\ttfamily Matrix\+Xd}), in which every entry is a {\ttfamily double} (hence the {\ttfamily d} in {\ttfamily Matrix\+Xd}). See the \mbox{\hyperlink{QuickReference.dox_QuickRef_Types}{quick reference guide}} for an overview of the different types you can use to represent a matrix.

The {\ttfamily Eigen/\+Dense} header file defines all member functions for the Matrix\+Xd type and related types (see also the \mbox{\hyperlink{QuickReference.dox_QuickRef_Headers}{table of header files}}). All classes and functions defined in this header file (and other \mbox{\hyperlink{namespace_eigen}{Eigen}} header files) are in the {\ttfamily \mbox{\hyperlink{namespace_eigen}{Eigen}}} namespace.

The first line of the {\ttfamily main} function declares a variable of type {\ttfamily Matrix\+Xd} and specifies that it is a matrix with 2 rows and 2 columns (the entries are not initialized). The statement {\ttfamily m(0,0) = 3} sets the entry in the top-\/left corner to 3. You need to use round parentheses to refer to entries in the matrix. As usual in computer science, the index of the first index is 0, as opposed to the convention in mathematics that the first index is 1.

The following three statements sets the other three entries. The final line outputs the matrix {\ttfamily m} to the standard output stream.\hypertarget{_getting_started_GettingStartedExample2}{}\doxysubsection{Example 2\+: Matrices and vectors}\label{_getting_started_GettingStartedExample2}
Here is another example, which combines matrices with vectors. Concentrate on the left-\/hand program for now; we will talk about the right-\/hand program later.

\tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Size set at run time\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Size set at compile time\+: }\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Size set at run time\+:}&\cellcolor{\tableheadbgcolor}\textbf{ Size set at compile time\+: }\\\cline{1-2}
\endhead

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
  &
\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 \\\cline{1-2}
\end{longtabu}


The output is as follows\+:


\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
\hypertarget{_getting_started_GettingStartedExplanation2}{}\doxysubsection{Explanation of the second example}\label{_getting_started_GettingStartedExplanation2}
The second example starts by declaring a 3-\/by-\/3 matrix {\ttfamily m} which is initialized using the \mbox{\hyperlink{class_eigen_1_1_dense_base_ae97f8d9d08f969c733c8144be6225756}{Random() }} method with random values between -\/1 and 1. The next line applies a linear mapping such that the values are between 10 and 110. The function call \mbox{\hyperlink{class_eigen_1_1_dense_base_a7be8d4ac974617fa319e42e714413efb}{Matrix\+Xd\+::\+Constant}}(3,3,1.\+2) returns a 3-\/by-\/3 matrix expression having all coefficients equal to 1.\+2. The rest is standard arithmetics.

The next line of the {\ttfamily main} function introduces a new type\+: {\ttfamily Vector\+Xd}. This represents a (column) vector of arbitrary size. Here, the vector {\ttfamily v} is created to contain {\ttfamily 3} coefficients which are left unitialized. The one but last line uses the so-\/called comma-\/initializer, explained in \mbox{\hyperlink{group___tutorial_advanced_initialization}{Tutorial\+Advanced\+Initialization}}, to set all coefficients of the vector {\ttfamily v} to be as follows\+:

\[ v = \begin{bmatrix} 1 \\ 2 \\ 3 \end{bmatrix}. \]

The final line of the program multiplies the matrix {\ttfamily m} with the vector {\ttfamily v} and outputs the result.

Now look back at the second example program. We presented two versions of it. In the version in the left column, the matrix is of type {\ttfamily Matrix\+Xd} which represents matrices of arbitrary size. The version in the right column is similar, except that the matrix is of type {\ttfamily Matrix3d}, which represents matrices of a fixed size (here 3-\/by-\/3). Because the type already encodes the size of the matrix, it is not necessary to specify the size in the constructor; compare {\ttfamily Matrix\+Xd m(3,3)} with {\ttfamily Matrix3d m}. Similarly, we have {\ttfamily Vector\+Xd} on the left (arbitrary size) versus {\ttfamily Vector3d} on the right (fixed size). Note that here the coefficients of vector {\ttfamily v} are directly set in the constructor, though the same syntax of the left example could be used too.

The use of fixed-\/size matrices and vectors has two advantages. The compiler emits better (faster) code because it knows the size of the matrices and vectors. Specifying the size in the type also allows for more rigorous checking at compile-\/time. For instance, the compiler will complain if you try to multiply a {\ttfamily Matrix4d} (a 4-\/by-\/4 matrix) with a {\ttfamily Vector3d} (a vector of size 3). However, the use of many types increases compilation time and the size of the executable. The size of the matrix may also not be known at compile-\/time. A rule of thumb is to use fixed-\/size matrices for size 4-\/by-\/4 and smaller.\hypertarget{_getting_started_GettingStartedConclusion}{}\doxysubsection{Where to go from here?}\label{_getting_started_GettingStartedConclusion}
It\textquotesingle{}s worth taking the time to read the \mbox{\hyperlink{group___tutorial_matrix_class}{long tutorial}}.

However if you think you don\textquotesingle{}t need it, you can directly use the classes documentation and our \mbox{\hyperlink{group___quick_ref_page}{Quick\+Ref\+Page}}.

\begin{DoxyItemize}
\item {\bfseries{Next\+:}} \mbox{\hyperlink{group___tutorial_matrix_class}{Tutorial\+Matrix\+Class}} \end{DoxyItemize}
\hypertarget{TutorialSparse_example_details}{}\doxysection{Tutorial\+Sparse\+\_\+example\+\_\+details}\label{TutorialSparse_example_details}

\begin{DoxyCodeInclude}{0}
\end{DoxyCodeInclude}
 \hypertarget{TopicWritingEfficientProductExpression}{}\doxysection{Writing efficient matrix product expressions}\label{TopicWritingEfficientProductExpression}
In general achieving good performance with \mbox{\hyperlink{namespace_eigen}{Eigen}} does no require any special effort\+: simply write your expressions in the most high level way. This is especially true for small fixed size matrices. For large matrices, however, it might be useful to take some care when writing your expressions in order to minimize useless evaluations and optimize the performance. In this page we will give a brief overview of the \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s internal mechanism to simplify and evaluate complex product expressions, and discuss the current limitations. In particular we will focus on expressions matching level 2 and 3 B\+L\+AS routines, i.\+e, all kind of matrix products and triangular solvers.

Indeed, in \mbox{\hyperlink{namespace_eigen}{Eigen}} we have implemented a set of highly optimized routines which are very similar to B\+L\+AS\textquotesingle{}s ones. Unlike B\+L\+AS, those routines are made available to user via a high level and natural A\+PI. Each of these routines can compute in a single evaluation a wide variety of expressions. Given an expression, the challenge is then to map it to a minimal set of routines. As explained latter, this mechanism has some limitations, and knowing them will allow you to write faster code by making your expressions more \mbox{\hyperlink{namespace_eigen}{Eigen}} friendly.\hypertarget{_topic_writing_efficient_product_expression_GEMM}{}\doxysubsection{General Matrix-\/\+Matrix product (\+G\+E\+M\+M)}\label{_topic_writing_efficient_product_expression_GEMM}
Let\textquotesingle{}s start with the most common primitive\+: the matrix product of general dense matrices. In the B\+L\+AS world this corresponds to the G\+E\+MM routine. Our equivalent primitive can perform the following operation\+: $ C.noalias() += \alpha op1(A) op2(B) $ where A, B, and C are column and/or row major matrices (or sub-\/matrices), alpha is a scalar value, and op1, op2 can be transpose, adjoint, conjugate, or the identity. When \mbox{\hyperlink{namespace_eigen}{Eigen}} detects a matrix product, it analyzes both sides of the product to extract a unique scalar factor alpha, and for each side, its effective storage order, shape, and conjugation states. More precisely each side is simplified by iteratively removing trivial expressions such as scalar multiple, negation and conjugation. \mbox{\hyperlink{class_eigen_1_1_transpose}{Transpose}} and \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expressions are not evaluated and they only modify the storage order and shape. All other expressions are immediately evaluated. For instance, the following expression\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() -\/= s4 * (s1 * m2.adjoint() * (-\/(s3*m3).conjugate()*s2))  }
\end{DoxyCode}
 is automatically simplified to\+: 
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += (s1*s2*conj(s3)*s4) * m2.adjoint() * m3.conjugate() }
\end{DoxyCode}
 which exactly matches our G\+E\+MM routine.\hypertarget{_topic_writing_efficient_product_expression_GEMM_Limitations}{}\doxysubsubsection{Limitations}\label{_topic_writing_efficient_product_expression_GEMM_Limitations}
Unfortunately, this simplification mechanism is not perfect yet and not all expressions which could be handled by a single G\+E\+M\+M-\/like call are correctly detected. \tabulinesep=1mm
\begin{longtabu}spread 0pt [c]{*{4}{|X[-1]}|}
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Not optimal expression }&\cellcolor{\tableheadbgcolor}\textbf{ Evaluated as }&\cellcolor{\tableheadbgcolor}\textbf{ Optimal version (single evaluation) }&\cellcolor{\tableheadbgcolor}\textbf{ Comments  }\\\cline{1-4}
\endfirsthead
\hline
\endfoot
\hline
\cellcolor{\tableheadbgcolor}\textbf{ Not optimal expression }&\cellcolor{\tableheadbgcolor}\textbf{ Evaluated as }&\cellcolor{\tableheadbgcolor}\textbf{ Optimal version (single evaluation) }&\cellcolor{\tableheadbgcolor}\textbf{ Comments  }\\\cline{1-4}
\endhead

\begin{DoxyCode}{0}
\DoxyCodeLine{m1 += m2 * m3; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{temp = m2 * m3;}
\DoxyCodeLine{m1 += temp; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += m2 * m3; }
\end{DoxyCode}
 &Use .noalias() to tell \mbox{\hyperlink{namespace_eigen}{Eigen}} the result and right-\/hand-\/sides do not alias. Otherwise the product m2 $\ast$ m3 is evaluated into a temporary.  \\\cline{1-4}
&&
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += s1 * (m2 * m3); }
\end{DoxyCode}
 &This is a special feature of \mbox{\hyperlink{namespace_eigen}{Eigen}}. Here the product between a scalar and a matrix product does not evaluate the matrix product but instead it returns a matrix product expression tracking the scalar scaling factor. ~\newline
 Without this optimization, the matrix product would be evaluated into a temporary as in the next example.  \\\cline{1-4}

\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += (m2 * m3).adjoint(); }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{temp = m2 * m3;}
\DoxyCodeLine{m1 += temp.adjoint(); }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += m3.adjoint()}
\DoxyCodeLine{               * m2.adjoint(); }
\end{DoxyCode}
 &This is because the product expression has the Eval\+Before\+Nesting bit which enforces the evaluation of the product by the Tranpose expression.  \\\cline{1-4}

\begin{DoxyCode}{0}
\DoxyCodeLine{m1 = m1 + m2 * m3; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{temp = m2 * m3;}
\DoxyCodeLine{m1 = m1 + temp; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += m2 * m3; }
\end{DoxyCode}
 &Here there is no way to detect at compile time that the two m1 are the same, and so the matrix product will be immediately evaluated.  \\\cline{1-4}

\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() = m4 + m2 * m3; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{temp = m2 * m3;}
\DoxyCodeLine{m1 = m4 + temp; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1 = m4;}
\DoxyCodeLine{m1.noalias() += m2 * m3; }
\end{DoxyCode}
 &First of all, here the .noalias() in the first expression is useless because m2$\ast$m3 will be evaluated anyway. However, note how this expression can be rewritten so that no temporary is required. (tip\+: for very small fixed size matrix it is slighlty better to rewrite it like this\+: m1.\+noalias() = m2 $\ast$ m3; m1 += m4;  \\\cline{1-4}

\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += (s1*m2).block(..) * m3; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{temp = (s1*m2).block(..);}
\DoxyCodeLine{m1 += temp * m3; }
\end{DoxyCode}
 &
\begin{DoxyCode}{0}
\DoxyCodeLine{m1.noalias() += s1 * m2.block(..) * m3; }
\end{DoxyCode}
 &This is because our expression analyzer is currently not able to extract trivial expressions nested in a \mbox{\hyperlink{class_eigen_1_1_block}{Block}} expression. Therefore the nested scalar multiple cannot be properly extracted.  \\\cline{1-4}
\end{longtabu}


Of course all these remarks hold for all other kind of products involving triangular or selfadjoint matrices. \hypertarget{Experimental}{}\doxysection{Experimental parts of Eigen}\label{Experimental}
\textbackslash{}eigen\+Auto\+Toc\hypertarget{_experimental_Experimental_summary}{}\doxysubsection{Summary}\label{_experimental_Experimental_summary}
With the 2.\+0 release, \mbox{\hyperlink{namespace_eigen}{Eigen}}\textquotesingle{}s A\+PI is, to a large extent, stable. However, we wish to retain the freedom to make A\+PI incompatible changes. To that effect, we call many parts of \mbox{\hyperlink{namespace_eigen}{Eigen}} \char`\"{}experimental\char`\"{} which means that they are not subject to A\+PI stability guarantee.

Our goal is that for the 2.\+1 release (expected in July 2009) most of these parts become A\+P\+I-\/stable too.

We are aware that A\+PI stability is a major concern for our users. That\textquotesingle{}s why it\textquotesingle{}s a priority for us to reach it, but at the same time we\textquotesingle{}re being serious about not calling \mbox{\hyperlink{namespace_eigen}{Eigen}} A\+P\+I-\/stable too early.

Experimental features may at any time\+: \begin{DoxyItemize}
\item be removed; \item be subject to an A\+PI incompatible change; \item introduce A\+PI or A\+BI incompatible changes in your own code if you let them affect your A\+PI or A\+BI.\end{DoxyItemize}
\hypertarget{_experimental_Experimental_modules}{}\doxysubsection{Experimental modules}\label{_experimental_Experimental_modules}
The following modules are considered entirely experimental, and we make no firm A\+PI stability guarantee about them for the time being\+: \begin{DoxyItemize}
\item S\+VD \item QR \item Cholesky \item \mbox{\hyperlink{struct_eigen_1_1_sparse}{Sparse}} \item Geometry (this one should be mostly stable, but it\textquotesingle{}s a little too early to make a formal guarantee)\end{DoxyItemize}
\hypertarget{_experimental_Experimental_core}{}\doxysubsection{Experimental parts of the Core module}\label{_experimental_Experimental_core}
In the Core module, the only classes subject to A\+BI stability guarantee (meaning that you can use it for data members in your public A\+BI) is\+: \begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} \item \mbox{\hyperlink{class_eigen_1_1_map}{Map}}\end{DoxyItemize}
All other classes offer no A\+BI guarantee, e.\+g. the layout of their data can be changed.

The only classes subject to (even partial) A\+PI stability guarantee (meaning that you can safely construct and use objects) are\+: \begin{DoxyItemize}
\item \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} \+: partial A\+PI stability (see below) \item \mbox{\hyperlink{class_eigen_1_1_matrix}{Matrix}} \+: full A\+PI stability (except for experimental stuff inherited from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}}) \item \mbox{\hyperlink{class_eigen_1_1_map}{Map}} \+: full A\+PI stability (except for experimental stuff inherited from \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}})\end{DoxyItemize}
All other classes offer no direct A\+PI guarantee, e.\+g. their methods can be changed; however notice that most classes inherit \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} and that this is where most of their A\+PI comes from -- so in practice most of the A\+PI is stable.

A few \mbox{\hyperlink{class_eigen_1_1_matrix_base}{Matrix\+Base}} methods are considered experimental, hence not part of any A\+PI stability guarantee\+: \begin{DoxyItemize}
\item all methods documented as internal \item all methods hidden in the Doxygen documentation \item all methods marked as experimental \item all methods defined in experimental modules \end{DoxyItemize}
