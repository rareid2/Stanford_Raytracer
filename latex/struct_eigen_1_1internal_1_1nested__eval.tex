\hypertarget{struct_eigen_1_1internal_1_1nested__eval}{}\doxysection{Eigen\+::internal\+::nested\+\_\+eval$<$ T, n, Plain\+Object $>$ Struct Template Reference}
\label{struct_eigen_1_1internal_1_1nested__eval}\index{Eigen::internal::nested\_eval$<$ T, n, PlainObject $>$@{Eigen::internal::nested\_eval$<$ T, n, PlainObject $>$}}
\doxysubsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1nested__eval_acfce1f0e560f4ab47f54b98b180bb338}\label{struct_eigen_1_1internal_1_1nested__eval_acfce1f0e560f4ab47f54b98b180bb338}} 
enum \{ \newline
{\bfseries Scalar\+Read\+Cost} = Num\+Traits$<$typename traits$<$T$>$\+::Scalar$>$\+::Read\+Cost, 
{\bfseries Coeff\+Read\+Cost} = evaluator$<$T$>$\+::Coeff\+Read\+Cost, 
{\bfseries N\+As\+Integer} = n == Dynamic ? Huge\+Cost \+: n, 
{\bfseries Cost\+Eval} = (N\+As\+Integer+1) $\ast$ Scalar\+Read\+Cost + Coeff\+Read\+Cost, 
\newline
{\bfseries Cost\+No\+Eval} = N\+As\+Integer $\ast$ Coeff\+Read\+Cost, 
{\bfseries Evaluate} = (int(evaluator$<$T$>$\+::Flags) \& Eval\+Before\+Nesting\+Bit) $\vert$$\vert$ (int(Cost\+Eval) $<$ int(Cost\+No\+Eval))
 \}
\item 
\mbox{\Hypertarget{struct_eigen_1_1internal_1_1nested__eval_a3e0ad119cd1fee5aba6b98cb7e7ad2fe}\label{struct_eigen_1_1internal_1_1nested__eval_a3e0ad119cd1fee5aba6b98cb7e7ad2fe}} 
typedef \mbox{\hyperlink{struct_eigen_1_1internal_1_1conditional}{conditional}}$<$ Evaluate, Plain\+Object, typename \mbox{\hyperlink{struct_eigen_1_1internal_1_1ref__selector}{ref\+\_\+selector}}$<$ \mbox{\hyperlink{class_eigen_1_1_triplet}{T}} $>$\+::\mbox{\hyperlink{struct_eigen_1_1internal_1_1true__type}{type}} $>$\+::\mbox{\hyperlink{struct_eigen_1_1internal_1_1true__type}{type}} {\bfseries type}
\end{DoxyCompactItemize}


The documentation for this struct was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/\+Users/rileyannereid/\+Pycharm\+Projects/\+Stanford\+\_\+\+Raytracer/damping/lib/eigen/\+Eigen/src/\+Core/util/Xpr\+Helper.\+h\end{DoxyCompactItemize}
